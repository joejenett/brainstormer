{"version":3,"sources":["webpack://dpack/webpack/universalModuleDefinition","webpack://dpack/webpack/bootstrap","webpack://dpack/./browser.js","webpack://dpack/./fetch.js","webpack://dpack/./lib/Options.js","webpack://dpack/./lib/parse.js","webpack://dpack/./lib/serialize.js","webpack://dpack/(webpack)/buildin/global.js","webpack://dpack/./xhr.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","serialize","parse","Options","createSerializer","createParser","fetch","XMLHttpRequest","readResponse","response","onProgress","reader","body","getReader","Promise","resolve","reject","parser","parsedData","queuedBytes","queueUnfinishedChar","bytes","length","lastStart","byte","needs","slice","decoder","TextDecoder","readNext","read","then","next","done","sourceText","decode","Uint8Array","Array","from","concat","onResume","updatedData","setSource","error","url","request","headers","fetchResponse","dpack","this","classByName","Map","converterByConstructor","addExtension","Class","options","set","fromArray","toArray","FALSE","TRUE","DEFAULT_TYPE","ARRAY_TYPE","REFERENCING_TYPE","NUMBER_TYPE","METADATA_TYPE","REFERENCING_POSITION","TYPE_DEFINITION","ERROR_METADATA","OPEN_SEQUENCE","END_SEQUENCE","DEFERRED_REFERENCE","offset","source","isPartial","pausedState","deferredReads","nonParsingError","pause","state","lastRead","previous","resume","Error","nextString","isPartialString","rebuildString","resumeState","disposedChars","readSequence","thisProperty","isArray","propertyState","propertyIndex","values","nextPosition","push","code","constructs","type","number","token","charCodeAt","resetTo","parent","undefined","forDeferred","previousProperty","recordValueReference","extendedType","fromValue","errorOnUnknownClass","parameter","metadata","onError","readMap","readSet","readDate","string","startOffset","hasMoreData","isPaused","hasUnfulfilledReferences","index","getOffset","shared","deferredRead","target","parentDeferredReads","targetProperty","result","null","assign","constructor","setPrototypeOf","getPrototypeOf","message","stringOrBuffer","toString","encoding","entries","map","entry","Set","size","add","time","Date","PROPERTY_CODE","TYPE_CODE","STRING_CODE","NUMBER_CODE","SEQUENCE_CODE","NULL","UNDEFINED","nextId","extendedTypes","toValue","writeMap","writeSet","writeDate","outlet","avoidShareUpdate","propertyUsed","charEncoder","global","Buffer","serialized","writeToken","serializedToken","String","fromCharCode","writeString","getSerialized","startSequence","endSequence","browserCharEncoder","nodeCharEncoder","writeBuffer","forProperty","pendingEncodings","bufferSymbol","targetSymbol","serializerId","writers","writeAsDefault","writeAsArray","writeAsReferencing","writeAsNumber","writeInlineString","serializer","reference","indexOf","writeNumber","writeSharedValue","writeTypedValue","writeProperty","writeTypedNonConstant","parentProperty","notPlainObject","writeBlockReference","iterator","iterable","arrayProperty","child","writeAsIterable","resumeIndex","lastPropertyIndex","getProperty","console","array","needsClosing","block","writer","blockProperty","lazyPromise","callback","upgrade","forBlock","buffer","lastPendingEncodings","unshift","apply","sharedProperty","promises","finished","promise","shift","all","flush","setOffset","getWriters","startWrite","endWrite","sizeTable","sizeTableSymbol","lazy","ArrayFrom","keyValue","forEach","keyValues","date","getTime","g","Function","eval","e","acceptSet","xhr","addEventListener","receivedData","originalSetRequestHeader","setRequestHeader","lastOffset","toLowerCase","originalSend","send","event","responseText","responseParsed","test","getResponseHeader","onerror","arguments"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dpack\"] = factory();\n\telse\n\t\troot[\"dpack\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./browser.js\");\n","var serialize = require('./lib/serialize')\r\nvar parse = require('./lib/parse')\r\nvar Options = require('./lib/Options').Options\r\n\r\nexports.serialize = serialize.serialize\r\nexports.parse = parse.parse\r\nexports.createSerializer = serialize.createSerializer\r\nexports.createParser = parse.createParser\r\nexports.Options = Options\r\nexports.fetch = require('./fetch').fetch\r\nexports.XMLHttpRequest = require('./xhr').XMLHttpRequest\r\n","\"use strict\"\r\nvar createParser = require('./lib/parse').createParser\r\n\r\nvar serialize = require('./lib/serialize').serialize\r\nfunction readResponse(response, onProgress) {\r\n\tvar reader = response.body.getReader()\r\n\treturn new Promise(function(resolve, reject) {\r\n\t\tvar parser\r\n\t\tvar parsedData\r\n\t\tvar queuedBytes\r\n\t\tfunction queueUnfinishedChar(bytes) {\r\n\t\t\t// this checks to see if we end the bytes in the middle of a character, and need to queue bytes for the next chunk\r\n\t\t\tvar length = bytes.length\r\n\t\t\tvar lastStart = length - 1\r\n\t\t\tif (bytes[lastStart] < 0x80) {\r\n\t\t\t\tqueuedBytes = null\r\n\t\t\t\treturn bytes\r\n\t\t\t}\r\n\t\t\twhile (lastStart >= 0) {\r\n\t\t\t\tvar byte = bytes[lastStart]\r\n\t\t\t\tif (byte >= 0xC0) {\r\n\t\t\t\t\tvar charLength = byte >= 0xE0 ? byte >= 0xF0 ? 4 : 3 : 2\r\n\t\t\t\t\tvar needs = charLength - length + lastStart\r\n\t\t\t\t\tif (needs > 0) {\r\n\t\t\t\t\t\tqueuedBytes = bytes.slice(lastStart, length - lastStart)\r\n\t\t\t\t\t\tqueuedBytes.needs = needs\r\n\t\t\t\t\t\treturn bytes.slice(0, lastStart)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tqueuedBytes = null\r\n\t\t\t\t\treturn bytes\r\n\t\t\t\t}\r\n\t\t\t\tlastStart--\r\n\t\t\t}\r\n\t\t\tqueuedBytes = null\r\n\t\t\treturn bytes\r\n\t\t}\r\n\t\tvar decoder = new TextDecoder()\r\n\t\tfunction readNext() {\r\n\t\t\treader.read().then(function(next) {\r\n\t\t\t\tif (next.done) {\r\n\t\t\t\t\tresolve(parsedData)\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tvar bytes = next.value\r\n\t\t\t\t\t\tvar sourceText\r\n\t\t\t\t\t\tif (queuedBytes) {\r\n\t\t\t\t\t\t\t// if we are resuming from the middle of a character, concatenate the bytes and decode it\r\n\t\t\t\t\t\t\tsourceText = decoder.decode(new Uint8Array(Array.from(queuedBytes).concat(Array.from(bytes.slice(0, queuedBytes.needs)))))\r\n\t\t\t\t\t\t\t// and then remove the consumed byte(s)\r\n\t\t\t\t\t\t\tbytes = bytes.slice(queuedBytes.needs)\r\n\t\t\t\t\t\t\tbytes = queueUnfinishedChar(bytes)\r\n\t\t\t\t\t\t\tsourceText += decoder.decode(bytes)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tbytes = queueUnfinishedChar(bytes)\r\n\t\t\t\t\t\t\tsourceText = decoder.decode(bytes)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (parser) {\r\n\t\t\t\t\t\t\tif (parser.onResume) {\r\n\t\t\t\t\t\t\t\tvar updatedData = parser.onResume(sourceText, true)\r\n\t\t\t\t\t\t\t\tparsedData = parsedData || updatedData\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tparser = createParser()\r\n\t\t\t\t\t\t\tparser.setSource(sourceText, 0, true)\r\n\t\t\t\t\t\t\tparsedData = parser.read()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tparser.read()\r\n\t\t\t\t\t\treadNext()\r\n\t\t\t\t\t} catch(error) {\r\n\t\t\t\t\t\treject(error)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, reject)\r\n\t\t}\r\n\t\treadNext()\r\n\t})\r\n}\r\nexports.readResponse = readResponse\r\nexports.fetch = function(url, request) {\r\n\t(request.headers || (request.headers = {}))['Accept'] = 'text/dpack;q=1,application/json;q=0.7'\r\n\tvar fetchResponse = fetch(url, request)\r\n\tfetchResponse.then(function(response) {\r\n\t\tresponse.dpack = function(onProgress) {\r\n\t\t\treturn readResponse(response, onProgress)\r\n\t\t}\r\n\t\treturn response\r\n\t})\r\n\treturn fetchResponse\r\n}\r\n","\"use strict\"\r\nfunction Options() {\r\n\tvar classByName = this.classByName = new Map()\r\n\tthis.converterByConstructor = new Map()\r\n\t//writerByConstructor.set(Map, writeMap)\r\n\t//writerByConstructor.set(Set, writeSet)\r\n}\r\nOptions.prototype.addExtension = function(Class, name, options) {\r\n\tif (name && Class.name !== name) {\r\n\t\tClass.name = name\r\n\t}\r\n\tthis.classByName.set(Class.name, (options && options.fromArray) ? options : Class)\r\n\tthis.converterByConstructor.set(Class, (options && options.toArray) ? options : Class)\r\n}\r\nexports.Options = Options\r\n","\"use strict\"\r\n\r\n// type codes:\r\n// these are the codes that are used to determine the rudimentary type of numbers\r\nvar PROPERTY_CODE = 0\r\nvar TYPE_CODE = 3\r\nvar STRING_CODE = 2\r\nvar NUMBER_CODE = 1\r\nvar SEQUENCE_CODE = 7\r\n\r\n// constant codes\r\nvar NULL = 0 // p\r\nvar FALSE = 3 // s\r\nvar TRUE = 4 // t\r\nvar UNDEFINED = 5 // u\r\n\r\n// these are the starting codes (structures also use this space) for complete types\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\nvar REFERENCING_TYPE = 8\r\nvar NUMBER_TYPE = 9\r\nvar EXTENSIONS = 10\r\nvar METADATA_TYPE = 11\r\nvar COPY_PROPERTY = 12  // for defining a typed object without returning the value\r\nvar REFERENCING_POSITION = 13\r\nvar TYPE_DEFINITION = 14  // for defining a typed object without returning the value\r\n\r\nvar ERROR_METADATA = 500\r\n// sequence codes\r\nvar OPEN_SEQUENCE = 12 // <\r\nvar PARTIAL_DEFERRED_REFERENCE = 12 // <\r\nvar END_SEQUENCE = 14 // >\r\nvar DEFERRED_REFERENCE = 15 // ?\r\n\r\nvar MAX_LENGTH = 1024*1024*16\r\nvar PAUSED = {}\r\n\r\nfunction createParser(options) {\r\n\tif (!options)\r\n\t\toptions = {}\r\n\tvar offset\r\n\tvar source\r\n\tvar isPartial\r\n\tvar classByName = options.classByName || new Map()\r\n\tclassByName.set('Map', readMap)\r\n\tclassByName.set('Set', readSet)\r\n\tclassByName.set('Date', readDate)\r\n\tvar pausedState\r\n\tvar deferredReads\r\n\r\n\tfunction pause(state, lastRead) {\r\n\t\tstate.previous = pausedState\r\n\t\tstate.resume = true\r\n\t\tpausedState = state\r\n\t\tif (!isPartial)\r\n\t\t\tthrow new Error('Unexpected end of dpack stream')\r\n\r\n\t\tif (!parser.onResume) // only if not already defined, otherwise we just want to use the one from the top of the call stack\r\n\t\t\tparser.onResume = function(nextString, isPartialString, rebuildString) {\r\n\t\t\t\t// top of the resume stack\r\n\t\t\t\tvar resumeState = pausedState\r\n\t\t\t\tpausedState = null\r\n\t\t\t\tparser.onResume = null\r\n\t\t\t\t// we slice and add these together to generate an entirely new string\r\n\t\t\t\t// so we don't cause a memory leak with redundant strings that a retained a slice parents\r\n\t\t\t\tif (lastRead < source.length)\r\n\t\t\t\t\tsource = source.slice(lastRead) + nextString\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (rebuildString) // if we have read all of source, we want to slice and re-concatenate to eliminate the slice reference to the parent, we really don't want that retained in memory\r\n\t\t\t\t\t\tsource = nextString.slice(0, 1) + nextString.slice(1)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tsource = nextString\r\n\t\t\t\t}\r\n\t\t\t\tisPartial = isPartialString\r\n\t\t\t\tdisposedChars += lastRead\r\n\t\t\t\toffset = 0\r\n\t\t\t\treturn resumeState.reader ? resumeState.reader(resumeState) : readSequence(resumeState.length, resumeState)\r\n\t\t\t}\r\n\t\treturn state.object\r\n\t}\r\n\r\n\tfunction readSequence(length, thisProperty) {\r\n\t\t/* propertyStates:\r\n\t\t0 - starting next property slot\r\n\t\t1 - property created, succeeding value should be value of property\r\n\t\t2 - property creation in progress, next value should define key\r\n\t\t11+ - modifying property, next value modifies property (adds metadata, position, type, etc.)\r\n\t\t*/\r\n\t\tvar propertyState = 0\r\n\t\tthisProperty = thisProperty || []\r\n\t\tvar property, isArray, object, value, i = 0, propertyIndex = 0\r\n\t\tif (thisProperty.resume) { // resuming, thisProperty is the resume state.\r\n\t\t\tproperty = thisProperty.previous\r\n\t\t\tif (property) {\r\n\t\t\t\t// do the previous/upper stack frame first\r\n\t\t\t\tvar value = property.reader ? property.reader(property) : readSequence(property.length, property)\r\n\t\t\t\tvar values = property.values\r\n\t\t\t\tif (values) {\r\n\t\t\t\t\t// we have an assignment to referencing values that is waiting for pausing to complete\r\n\t\t\t\t\tif (pausedState) {\r\n\t\t\t\t\t\t// if still paused, pass on to next pausedState\r\n\t\t\t\t\t\tpausedState.values = values\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (value.nextPosition > -1) {\r\n\t\t\t\t\t\t\t// we use this path for fulfilling forward references, and when the position is reset\r\n\t\t\t\t\t\t\tvalues[values.nextPosition++] = value\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (thisProperty.code && thisProperty.code !== thisProperty.thisProperty.code) {\r\n\t\t\t\tthisProperty.resume = false // if the resume property has been reassigned to an incompatible type, can't switch\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ti = thisProperty.i || 0\r\n\t\t\t\tobject = thisProperty.object\r\n\t\t\t\tpropertyState = thisProperty.propertyState || 0\r\n\t\t\t\tpropertyIndex = thisProperty.propertyIndex || 0\r\n\t\t\t\tthisProperty = thisProperty.thisProperty\r\n\t\t\t}\r\n\t\t}\r\n\t\tisArray = thisProperty.code === ARRAY_TYPE/*ARRAY_TYPE*/\r\n\t\tobject = object || (thisProperty.constructs ? new thisProperty.constructs() : isArray ? [] : {}) // TODO: we could probably construct a new reader that does this a little faster\r\n\t\tfor (; i < length;) {\r\n\t\t\tvar type, number\r\n\t\t\tvar lastRead = offset\r\n\t\t\tvar token = source.charCodeAt(offset++)\r\n\t\t\tif (token >= 0x30) { // fast path for one byte with stop bit\r\n\t\t\t\tif (token > 0x3000) { // long-token handling\r\n\t\t\t\t\ttype = (token >>> 12) ^ 4\r\n\t\t\t\t\tnumber = token & 0xfff\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = (token >>> 4) ^ 4\r\n\t\t\t\t\tnumber = token & 0xf\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttype = (token >>> 4) & 11 // shift and omit the stop bit (bit 3)\r\n\t\t\t\tnumber = token & 0xf\r\n\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 10 bit number\r\n\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 16 bit number\r\n\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 22 bit number\r\n\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 28 bit number\r\n\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 34 bit number (we can't use 32-bit shifting operators anymore)\r\n\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 40 bit number\r\n\t\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 46 bit number, we don't go beyond this\r\n\t\t\t\t\t\t\t\t\t\tif (!(token >= 0)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t\t\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (type === 0) { /*PROPERTY_CODE*/\r\n\t\t\t\tpropertyIndex = number\r\n\t\t\t\tpropertyState = 0\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\tif (type === 3) { /*TYPE_CODE*/\r\n\t\t\t\t// we store the previous property state in token, so we can assign the next one\r\n\t\t\t\tif (number < 6) {\r\n\t\t\t\t\t// special values (constants, deferreds)\r\n\t\t\t\t\tif (number < 3) {\r\n\t\t\t\t\t\tif (number === 0) {\r\n\t\t\t\t\t\t\tvalue = null\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalue = 'Unknown token, type: ' + type + ' number: ' + number\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (number === TRUE) {\r\n\t\t\t\t\t\t\tvalue = true\r\n\t\t\t\t\t\t} else if (number === FALSE) {\r\n\t\t\t\t\t\t\tvalue = false\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalue = undefined\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (number <= NUMBER_TYPE) {\r\n\t\t\t\t\t\t// property definition\r\n\t\t\t\t\t\tif (propertyState === 1) {\r\n\t\t\t\t\t\t\t// we were in property value position, but no value, so we increment position here\r\n\t\t\t\t\t\t\tpropertyIndex++\r\n\t\t\t\t\t\t\ti++\r\n\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (propertyIndex < thisProperty.resetTo) {\r\n\t\t\t\t\t\t\tthrow new Error('Overwriting frozen property')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (property) {\r\n\t\t\t\t\t\t\tif (!property.resume) {\r\n\t\t\t\t\t\t\t\tvalue = property.key // inherit the existing key\r\n\t\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex] = []\r\n\t\t\t\t\t\t\t\tproperty.key = value\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else { // no property existed in slot, start with default key of null\r\n\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex] = []\r\n\t\t\t\t\t\t\tproperty.key = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproperty.code = number\r\n\t\t\t\t\t\tproperty.parent = thisProperty\r\n\t\t\t\t\t\t//property.key = null\r\n\t\t\t\t\t\tpropertyState = 2 // read next value as the key\r\n\t\t\t\t\t\tif (number === REFERENCING_TYPE/*REFERENCING_TYPE*/) {\r\n\t\t\t\t\t\t\tproperty.values = []\r\n\t\t\t\t\t\t} else if (number === ARRAY_TYPE) {\r\n\t\t\t\t\t\t\tproperty[0] = []\r\n\t\t\t\t\t\t\tproperty[0].key = null\r\n\t\t\t\t\t\t\tproperty[0].code = DEFAULT_TYPE\r\n\t\t\t\t\t\t\tproperty[0].parent = property\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// property modification\r\n\t\t\t\t\t\tpropertyState = number\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (type === 2 /*STRING_CODE*/) {\r\n\t\t\t\t\tvalue = source.slice(offset, offset += number)\r\n\t\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\tpropertyState: propertyState\r\n\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (propertyState < 2) {\r\n\t\t\t\t\t\tif (property.code === NUMBER_TYPE/*NUMBER_TYPE*/) {\r\n\t\t\t\t\t\t\tvalue = +value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (type === 1) { /*NUMBER_CODE*/\r\n\t\t\t\t\tvalue = number\r\n\t\t\t\t} else { /*if type == 7 SEQUENCE_CODE*/\r\n\t\t\t\t\tif (number > 13) {\r\n\t\t\t\t\t\tif (number === END_SEQUENCE)\r\n\t\t\t\t\t\t\treturn object\r\n\t\t\t\t\t\telse if (number === DEFERRED_REFERENCE) {\r\n\t\t\t\t\t\t\tvalue = readSequence(0, property)\r\n\t\t\t\t\t\t\tpropertyState = 0\r\n\t\t\t\t\t\t\tif (options.forDeferred) {\r\n\t\t\t\t\t\t\t\tvalue = options.forDeferred(value, property)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t(deferredReads || (deferredReads = [])).push({\r\n\t\t\t\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (number >= OPEN_SEQUENCE) {\r\n\t\t\t\t\t\t\tnumber = 2000000000\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (propertyState > 1) {\r\n\t\t\t\t\t\t\tif (propertyState === 2) {\r\n\t\t\t\t\t\t\t\tpropertyState = 0 // if the property key was skipped, go directly into value mode\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\t\t} else if (propertyState === METADATA_TYPE)\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, [{ key: null, code: 6 }])\r\n\t\t\t\t\t\t\telse if (property.resume && (property.code || DEFAULT_TYPE) === property.thisProperty.code)\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property.thisProperty)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\tif (pausedState) {\r\n\t\t\t\t\t\t\tif (value === undefined) { // or a PAUSED object\r\n\t\t\t\t\t\t\t\tpausedState = null // erase anything further up in the stack, as this means the sequence couldn't start, so we need to re-parse from here\r\n\t\t\t\t\t\t\t\tparser.onResume = null\r\n\t\t\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\t\t\tpreviousProperty: previousProperty,\r\n\t\t\t\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// need to assign the values *after* the completion of the sequence if it is a forward reference\r\n\t\t\t\t\t\t\t\tpausedState.values = values\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}/*else if (values) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}*/\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!property) {\r\n\t\t\t\tthrow new Error('No property defined for slot' + (thisProperty.key ? ' in ' + thisProperty.key : ''))\r\n\t\t\t}\r\n\t\t\tif (propertyState < 2 && property && property.code === REFERENCING_TYPE/*REFERENCING_TYPE*/) {\r\n\t\t\t\tvar values = property.values\r\n\t\t\t\tif (typeof value === 'number') {\r\n\t\t\t\t\tvalue = values[number]\r\n\t\t\t\t\tif (value === undefined && !((number) in values)) {\r\n\t\t\t\t\t\tthrow new Error('Referencing value that has not been read yet')\r\n\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t} else if ((type === 2 || type === 7) && values) { // only strings and sequences\r\n\t\t\t\t\tif (values.nextPosition > -1) {\r\n\t\t\t\t\t\t// we use this path for fulfilling forward references\r\n\t\t\t\t\t\tif (property.recordValueReference) {\r\n\t\t\t\t\t\t\tproperty.recordValueReference(values)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[values.nextPosition++] = value\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (propertyState > 1) {\r\n\t\t\t\t// 0, 1: values are the value of the property\r\n\t\t\t\tif (propertyState === 2) { // property key\r\n\t\t\t\t\tproperty.key = value\r\n\t\t\t\t} else if (propertyState === METADATA_TYPE) { // 3: metadata paramater\r\n\t\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\t\tvar extendedType = classByName.get(value)\r\n\t\t\t\t\t\tif (extendedType) {\r\n\t\t\t\t\t\t\tif (extendedType.fromValue) {\r\n\t\t\t\t\t\t\t\tproperty.fromValue = extendedType.fromValue\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tproperty.constructs = extendedType\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (options.errorOnUnknownClass) {\r\n\t\t\t\t\t\t\tthrow new Error('Attempt to deserialize to unknown class ' + parameter)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// if no warning, just parse as a plain value/object\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproperty.extendedType = extendedType // if this gets used for serialization, this is needed\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// extended metadata assignment (used by shared structures to mark objects as unstructured)\r\n\t\t\t\t\t\tproperty.metadata = value\r\n\t\t\t\t\t\tif (value === ERROR_METADATA)\r\n\t\t\t\t\t\t\tproperty.fromValue = onError\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (propertyState === REFERENCING_POSITION) {\r\n\t\t\t\t\tvar values = property.values || (property.values = [])\r\n\t\t\t\t\t//values.splice(value, values.length)\r\n\t\t\t\t\tvalues.nextPosition = value\r\n\t\t\t\t} else if (propertyState === TYPE_DEFINITION) { // for type-only state\r\n\t\t\t\t\t// throw away this value and read next value as the real value\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Unknown property type ' + propertyState)\r\n\t\t\t\t}\r\n\t\t\t\tpropertyState = 1 // property value after definition position\r\n\t\t\t\tcontinue // read next value as the property value\r\n\t\t\t} else {\r\n\t\t\t\tpropertyState = 0\r\n\t\t\t}\r\n\t\t\tif (property.fromValue) {\r\n\t\t\t\tvalue = property.fromValue(value)\r\n\t\t\t}\r\n\t\t\tif (isArray && property.key === null) {\r\n\t\t\t\tobject.push(value)\r\n\t\t\t} else if (value !== undefined) {\r\n\t\t\t\tobject[property.key] = value\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t\tif (!isArray)\r\n\t\t\t\tpropertyIndex++\r\n\t\t}\r\n\t\treturn object\r\n\t}\r\n\r\n\tfunction unknownType(number) {\r\n\t\tthrow new Error('Unknown type ' + number)\r\n\t}\r\n\tvar nonParsingError\r\n\tfunction onError(error) {\r\n\t\tif (options.onError)\r\n\t\t\toptions.onError(error)\r\n\t\telse {\r\n\t\t\tnonParsingError = true\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\r\n\tvar disposedChars = 0\r\n\tfunction read(property) {\r\n\t\ttry {\r\n\t\t\tif (property && property.resume) {\r\n\t\t\t\tvar previous = property.previous\r\n\t\t\t\tvalue = readSequence(previous.length, previous)\r\n\t\t\t\t// once we get the value, we don't know which point in the stack could still be resolving\r\n\t\t\t\tvalue = property.object || value\r\n\t\t\t\tproperty = property.property\r\n\t\t\t} else {\r\n\t\t\t\tproperty = property || [options && options.shared || {\r\n\t\t\t\t\tkey: null,\r\n\t\t\t\t\tcode: 6\r\n\t\t\t\t}]\r\n\t\t\t\tvar value = readSequence(1, property)[property[0].key]\r\n\t\t\t}\r\n\t\t\twhile (true) {\r\n\t\t\t\tif (pausedState) {\r\n\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\treader: read,\r\n\t\t\t\t\t\tobject: value,\r\n\t\t\t\t\t\tproperty: property\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (!deferredReads) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tvar index = deferredReads.index || 0\r\n\t\t\t\tvar deferredRead = deferredReads[index]\r\n\t\t\t\tdeferredReads.index = index + 1\r\n\t\t\t\tif (!deferredRead) {\r\n\t\t\t\t\tdeferredReads = deferredReads.parent\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tvar target = deferredRead.value\r\n\t\t\t\tvar parentDeferredReads = deferredReads\r\n\t\t\t\tdeferredReads = []\r\n\t\t\t\tdeferredReads.parent = parentDeferredReads\r\n\t\t\t\tvar targetProperty = deferredRead.property\r\n\t\t\t\tvar result = readSequence(1, property = [{\r\n\t\t\t\t\tresume: true,\r\n\t\t\t\t\tkey: null,\r\n\t\t\t\t\tthisProperty: targetProperty,\r\n\t\t\t\t\tobject: target\r\n\t\t\t\t}])\r\n\t\t\t\tresult = result.null || result[targetProperty.key] // Blocks should use null as the root key, but could have the target property key as well\r\n\t\t\t\tif (result != target) { // This should only occur with a promise that resolves to a different type, an array\r\n\t\t\t\t\t// object was replaced with something else (an array, presumably)\r\n\t\t\t\t\tObject.assign(target, result)\r\n\t\t\t\t\tif (pausedState && pausedState.object === result) {\r\n\t\t\t\t\t\tpausedState.object = target\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (result && result.constructor === Array) {\r\n\t\t\t\t\t\ttarget.length = result.length\r\n\t\t\t\t\t\tObject.setPrototypeOf(target, Object.getPrototypeOf(result)) // do our best to make it array like\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch(error) {\r\n\t\t\tif (!nonParsingError)\r\n\t\t\t\terror.message = 'DPack parsing error: ' + error.message + ' at position: ' + (offset + disposedChars) + ' near: ' + source.slice(offset - 10, offset + 10)\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\r\n\tvar parser = {\r\n\t\tsetSource: function(string, startOffset, isPartialString) {\r\n\t\t\tsource = string\r\n\t\t\toffset = startOffset || 0\r\n\t\t\tdisposedChars = 0\r\n\t\t\tisPartial = isPartialString\r\n\t\t\treturn this\r\n\t\t},\r\n\t\thasMoreData: function() {\r\n\t\t\treturn source.length > offset\r\n\t\t},\r\n\t\tisPaused: function() {\r\n\t\t\treturn pausedState\r\n\t\t},\r\n\t\thasUnfulfilledReferences: function() {\r\n\t\t\treturn deferredReads && deferredReads.length > deferredReads.index\r\n\t\t},\r\n\t\tgetOffset: function() {\r\n\t\t\treturn offset + disposedChars\r\n\t\t},\r\n\t\tread: read\r\n\t}\r\n\treturn parser\r\n}\r\nexports.parse = function(stringOrBuffer, options) {\r\n\tvar source\r\n\tif (typeof stringOrBuffer === 'string') {\r\n\t\tsource = stringOrBuffer\r\n\t} else if (stringOrBuffer && stringOrBuffer.toString) {\r\n\t\tsource = stringOrBuffer.toString(options && options.encoding || 'utf8')\r\n\t} else { // whatever (undefined or null or whatever), just return it\r\n\t\treturn stringOrBuffer\r\n\t}\r\n\tvar parser = createParser(options).setSource(source)\r\n\tif (options && options.shared)\r\n\t\treturn parser.read([options.shared])\r\n\treturn parser.read()\r\n}\r\nexports.createParser = createParser\r\n\r\nvar readMap = {\r\n\tfromValue: function(entries) {\r\n\t\tvar map = new Map()\r\n\t\tfor (var i = 0, l = entries.length; i < l; i++) {\r\n\t\t\tvar entry = entries[i]\r\n\t\t\tmap.set(entry.key, entry.value)\r\n\t\t}\r\n\t\treturn map\r\n\t}\r\n}\r\nvar readSet = {\r\n\tfromValue: function(values) {\r\n\t\tvar set = new Set(values)\r\n\t\tif (set.size === 0 && values.length > 0) {\r\n\t\t\tfor (var i = 0, l = values.length; i < l; i++) {\r\n\t\t\t\tset.add(values[i])\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn set\r\n\t}\r\n}\r\nvar readDate = {\r\n\tfromValue: function(time) {\r\n\t\treturn new Date(time)\r\n\t}\r\n}\r\n\r\n","\"use strict\"\r\n// these are the codes that are used to determine the rudimentary type of numbers\r\nvar PROPERTY_CODE = 0\r\nvar TYPE_CODE = 3\r\nvar STRING_CODE = 2\r\nvar NUMBER_CODE = 1\r\nvar SEQUENCE_CODE = 7\r\n\r\n// constant codes\r\nvar NULL = 0 // p\r\nvar FALSE = 3 // s\r\nvar TRUE = 4 // t\r\nvar UNDEFINED = 5 // u\r\n\r\n// these are the starting codes (structures also use this space) for complete types\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\nvar REFERENCING_TYPE = 8\r\nvar NUMBER_TYPE = 9\r\nvar EXTENSIONS = 10\r\nvar METADATA_TYPE = 11\r\nvar COPY_PROPERTY = 12  // for defining a typed object without returning the value\r\nvar REFERENCING_POSITION = 13\r\nvar TYPE_DEFINITION = 14  // for defining a typed object without returning the value\r\n\r\nvar ERROR_METADATA = 500\r\n\r\n// sequence codes\r\nvar OPEN_SEQUENCE = 12 // <\r\nvar PARTIAL_DEFERRED_REFERENCE = 12 // <\r\nvar END_SEQUENCE = 14 // >\r\nvar DEFERRED_REFERENCE = 15 // ?\r\nvar nextId = 1\r\n\r\nfunction createSerializer(options) {\r\n\tif (!options)\r\n\t\toptions = {}\r\n\tvar extendedTypes = options.converterByConstructor\r\n\tif (!extendedTypes) {\r\n\t\textendedTypes = new Map()\r\n\t}\r\n\textendedTypes.set(Map, {\r\n\t\tname: 'Map',\r\n\t\ttoValue: writeMap\r\n\t})\r\n\textendedTypes.set(Set, {\r\n\t\tname: 'Set',\r\n\t\ttoValue: writeSet\r\n\t})\r\n\textendedTypes.set(Date, {\r\n\t\tname: 'Date',\r\n\t\ttoValue: writeDate\r\n\t})\r\n\tvar avoidShareUpdate = options.outlet || options.avoidShareUpdate\r\n\tvar charEncoder = (typeof global != 'undefined' && global.Buffer && !(options && options.encoding === 'utf16le')) ? exports.nodeCharEncoder(options) : browserCharEncoder(options)\r\n\tvar writeString = charEncoder.writeString\r\n\tvar writeToken = charEncoder.writeToken\r\n\tvar startSequence = charEncoder.startSequence\r\n\tvar endSequence = charEncoder.endSequence\r\n\tvar writeBuffer = charEncoder.writeBuffer\r\n\tvar forProperty = options.forProperty\r\n\tvar propertyUsed\r\n\tvar valueUsed\r\n\tif (options.shared) {\r\n\t\tpropertyUsed = options.shared.propertyUsed\r\n\t\tvalueUsed = options.shared.propertyUsed\r\n\t}\r\n\tvar pendingEncodings = []\r\n\tvar nextPropertyIndex = 8\r\n\tvar property\r\n\tvar bufferSymbol = exports.bufferSymbol || '_bufferSymbol_'\r\n\tvar targetSymbol = exports.targetSymbol || '_targetSymbol_'\r\n\tvar propertyComparisons = 0\r\n\tvar serializerId = nextId++\r\n\r\n\tvar writers = [\r\n\t\t0, 1, 2, 3, 4 , 5,\r\n\t\twriteAsDefault,\r\n\t\twriteAsArray,\r\n\t\twriteAsReferencing,\r\n\t\twriteAsNumber,\r\n\t\twriteOnlyNull\r\n\t]\r\n\t// write a rudimentary number\r\n\tfunction writeNumber(number) {\r\n\t\twriteToken(NUMBER_CODE, number)\r\n\t}\r\n\t// write a rudimentary string\r\n\tfunction writeInlineString(string) {\r\n\t\twriteToken(STRING_CODE, string.length)\r\n\t\twriteString(string)\r\n\t}\r\n\r\n\t// writing any value in referencing serialization type mode\r\n\tfunction writeAsReferencing(value) {\r\n\t\tvar type, values = property.values\r\n\t\tif (values) {\r\n\t\t\tif (values.resetTo > -1 && values.serializer !== serializerId) {\r\n\t\t\t\t// if this is a shared values, need to reset on each serialization\r\n\t\t\t\tvalues.serializer = serializerId\r\n\t\t\t\tif (values.resetTo < values.length)\r\n\t\t\t\t\tvalues.length = values.resetTo\r\n\t\t\t\twriteToken(TYPE_CODE, REFERENCING_POSITION)\r\n\t\t\t\twriteToken(NUMBER_CODE, values.resetTo)\r\n\t\t\t}\r\n\t\t\tvar reference = values.indexOf(value)\r\n\t\t\tif (reference > -1) {\r\n\t\t\t\treturn writeNumber(reference)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((type = typeof value) === 'string' || type ==='object' && value) {\r\n\t\t\tif (property.writeSharedValue) {\r\n\t\t\t\tif (property.writeSharedValue(value, writeToken, serializerId))\r\n\t\t\t\t\treturn\r\n\t\t\t} else if (values) {\r\n\t\t\t\tvar index = values.length\r\n\t\t\t\tif (index < 12)\r\n\t\t\t\t\tvalues[index] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (type === 'string') {\r\n\t\t\twriteInlineString(value)\r\n\t\t} else {\r\n\t\t\twriteAsDefault(value)\r\n\t\t}\r\n\t}\r\n\r\n\t// writing any value in number serialization type mode\r\n\tfunction writeAsNumber(number) {\r\n\t\tvar type = typeof number\r\n\t\tif (type === 'number') {\r\n\t\t\tif (number >>> 0 === number || (number > 0 && number < 0x400000000000 && number % 1 === 0)) {\r\n\t\t\t\t// 46 bit unsigned integer\r\n\t\t\t\twriteToken(NUMBER_CODE, number)\r\n\t\t\t} else {\r\n\t\t\t\t// decimal number serialized as a string\r\n\t\t\t\tvar asString = number.toString()\r\n\t\t\t\twriteInlineString(asString)\r\n\t\t\t}\r\n\t\t} else if (type === 'object') {\r\n\t\t\twriteAsDefault(number)\r\n\t\t} else {\r\n\t\t\twriteTypedValue(number)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeTypedValue(value) {\r\n\t\tif (value === null)\r\n\t\t\twriteToken(TYPE_CODE, NULL)\r\n\t\telse if (value === false)\r\n\t\t\twriteToken(TYPE_CODE, FALSE)\r\n\t\telse if (value === true)\r\n\t\t\twriteToken(TYPE_CODE, TRUE)\r\n\t\telse if (value === undefined)\r\n\t\t\twriteToken(TYPE_CODE, UNDEFINED)\r\n\t\telse {\r\n\t\t\twriteTypedNonConstant(value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeTypedNonConstant(value) {\r\n\t\tvar type = typeof value\r\n\t\tvar extendedType\r\n\t\tif (type === 'object') {\r\n\t\t\tif (value) {\r\n\t\t\t\tvar constructor = value.constructor\r\n\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t// leave type as is\r\n\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\ttype = 'array'\r\n\t\t\t\t} else {\r\n\t\t\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (property.type === type) {\r\n\t\t\t\t\t\t\t// if we are the right type after doing the conversion, go back to the original property to serialize\r\n\t\t\t\t\t\t\tif (property.extendedType !== extendedType) {\r\n\t\t\t\t\t\t\t\tproperty.extendedType = extendedType\r\n\t\t\t\t\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\t\t\t\t\twriteInlineString(extendedType.name)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn writers[property.code](value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t} else { // null\r\n\t\t\t\ttype = 'undefined' // treat null as same type as undefined, both constants\r\n\t\t\t}\r\n\t\t} else if (type === 'boolean') {\r\n\t\t\ttype = 'undefined'\r\n\t\t} else if (type === 'function') {\r\n\t\t\tvalue = value.toString()\r\n\t\t\ttype = 'string'\r\n\t\t}\r\n\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\twriters[property.code](value)\r\n\t}\r\n\r\n\tfunction writeOnlyNull() {\r\n\t\twriteToken(TYPE_CODE, NULL)\r\n\t}\r\n\r\n\t// writing any value in default serialization type mode\r\n\tfunction writeAsDefault(value, parentProperty) {\r\n\t\tvar type = typeof value\r\n\t\tif (type === 'object') {\r\n\t\t\tif (!value) {\r\n\t\t\t\treturn writeToken(TYPE_CODE, NULL)\r\n\t\t\t}\r\n\t\t\t// else continue with the object code\r\n\t\t} else if (type === 'string') {\r\n\t\t\treturn writeInlineString(value)\r\n\t\t} else if (type === 'number' && (value >>> 0 === value || (value > 0 && value < 0x400000000000 && value % 1 === 0))) {\r\n\t\t\t// 46 bit unsigned integer\r\n\t\t\treturn writeToken(NUMBER_CODE, value)\r\n\t\t} else {\r\n\t\t\treturn writeTypedValue(value)\r\n\t\t}\r\n\t\tvar object = value\r\n\t\tvar constructor = object.constructor\r\n\t\tvar notPlainObject\r\n\t\tif (object[targetSymbol]) {\r\n\t\t\treturn writeBlockReference(value)\r\n\t\t} else if (constructor === Object) {\r\n\t\t\tnotPlainObject = false\r\n\t\t} else if (constructor === Array) {\r\n\t\t\tproperty = writeProperty(property.key, 'array')\r\n\t\t\treturn writers[property.code](value, parentProperty)\r\n\t\t} else {\r\n\t\t\tif (object.then) {\r\n\t\t\t\treturn writeBlockReference(value)\r\n\t\t\t}\r\n\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\tif (extendedType) {\r\n\t\t\t\tif (extendedType.toValue) {\r\n\t\t\t\t\treturn writeTypedValue(object)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\textendedTypes.set(constructor, extendedType = {\r\n\t\t\t\t\tname: constructor.name\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (property.constructs !== constructor) {\r\n\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\twriteInlineString(extendedType.name)\r\n\t\t\t\tproperty.constructs = constructor\r\n\t\t\t}\r\n\t\t\tif (typeof Symbol !== 'undefined' && object[Symbol.iterator]) {\r\n\t\t\t\twriteProperty(property.key, 'array')\r\n\t\t\t\twriteAsIterable(object)\r\n\t\t\t}\r\n\t\t\tnotPlainObject = true\r\n\t\t}\r\n\t\tvar thisProperty = property\r\n\t\tif (thisProperty.resetTo < thisProperty.length && thisProperty.serializer != serializerId) {\r\n\t\t\tthisProperty.length = thisProperty.resetTo\r\n\t\t\tthisProperty.serializer = serializerId\r\n\t\t}\r\n\t\tstartSequence()\r\n\t\tvar i = 0\r\n\t\t//var sparse = false // densely packed property references can be searched more quickly\r\n\t\tvar resumeIndex = -2 // -2 denotes densely packed property references \r\n\t\tvar propertyIndex = 0\r\n\t\tfor (var key in object) {\r\n\t\t\tif (notPlainObject && !object.hasOwnProperty(key))\r\n\t\t\t\tcontinue\r\n\t\t\tvar value = object[key]\r\n\t\t\ttype = typeof value\r\n\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\tvar constructor\r\n\t\t\tvar extendedType = false\r\n\t\t\tif (type === 'object') {\r\n\t\t\t\tif (value) {\r\n\t\t\t\t\tconstructor = value.constructor\r\n\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\t// leave type as is\r\n\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { // null\r\n\t\t\t\t\ttype = 'undefined' // treat null as same type as undefined (and boolean), both constants that can go in any type\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!property || property.key !== key ||\r\n\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t(extendedType && property.extendedType !== constructor)) {\r\n\t\t\t\tvar lastPropertyIndex = propertyIndex\r\n\t\t\t\t// property doesn't match, search for it through existing properties\r\n\t\t\t\t// note that we are starting at the current propertyIndex, so this makes the assumption that\r\n\t\t\t\t// properties are rarely ever swapped, so possible property slots are always forward\r\n\t\t\t\tif (resumeIndex > -2)\r\n\t\t\t\t\tpropertyIndex = resumeIndex\r\n\t\t\t\tdo {\r\n\t\t\t\t\tproperty = thisProperty[++propertyIndex]\r\n\t\t\t\t} while(property && (property.key !== key ||\r\n\t\t\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t\t(extendedType && property.extendedType !== constructor)))\r\n\t\t\t\tif (property) {\r\n\t\t\t\t\t// found a match, reference it\r\n\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\tif (resumeIndex === -2) {\r\n\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (thisProperty.getProperty) {\r\n\t\t\t\t\t// a shared property, let it allocate ids\r\n\t\t\t\t\tproperty = thisProperty.getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex)\r\n\t\t\t\t\tpropertyIndex = property.index\r\n\t\t\t\t\tif (lastPropertyIndex !== propertyIndex && resumeIndex === -2) {\r\n\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (lastPropertyIndex === thisProperty.length) {\r\n\t\t\t\t\t\tpropertyIndex = lastPropertyIndex\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex = thisProperty.length)\r\n\t\t\t\t\t\tif (resumeIndex === -2) {\r\n\t\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (propertyIndex < thisProperty.resetTo) {\r\n\t\t\t\t\t\tdebugger\r\n\t\t\t\t\t\tthrow new Error('overwriting frozen property')\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tproperty = thisProperty[propertyIndex] = writeProperty(key, type, extendedType)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (propertyUsed)\r\n\t\t\t\tpropertyUsed(property, object, serializerId, i)\r\n//\t\t\tif (property.resumeIndex) // TODO: add a flag to enable this when property ordering can be assumed\r\n//\t\t\t\tresumeIndex = property.resumeIndex\r\n\t\t\tvar code = property.code\r\n\t\t\tif (code > 7) {\r\n\t\t\t\tif (code === 8)\r\n\t\t\t\t\twriteAsReferencing(value)\r\n\t\t\t\telse\r\n\t\t\t\t\twriteAsNumber(value)\r\n\t\t\t} else {\r\n\t\t\t\tif (code === 6) \r\n\t\t\t\t\twriteAsDefault(value)\r\n\t\t\t\telse\r\n\t\t\t\t\twriteAsArray(value)\r\n\t\t\t}\r\n\t\t\tpropertyIndex++\r\n\t\t\ti++\r\n\t\t}\r\n\t\tproperty = thisProperty\r\n\t\tendSequence(i)\r\n\t}\r\n\r\n\tfunction writeProperty(key, type, extendedType) {\r\n\t\tvar property\r\n\t\tproperty = []\r\n\t\tproperty.key = key\r\n\t\tproperty.type = type\r\n\t\tif (type === 'string') {\r\n\t\t\twriteToken(TYPE_CODE, REFERENCING_TYPE)\r\n\t\t\tproperty.values = []\r\n\t\t\tproperty.code = REFERENCING_TYPE\r\n\t\t} else if (type === 'number') {\r\n\t\t\twriteToken(TYPE_CODE, NUMBER_TYPE)\r\n\t\t\tproperty.code = NUMBER_TYPE\r\n\t\t} else if (type === 'object') {\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t} else if (type === 'array') {\r\n\t\t\twriteToken(TYPE_CODE, ARRAY_TYPE)\r\n\t\t\tproperty.code = ARRAY_TYPE\r\n\t\t} else if (type === 'boolean' || type === 'undefined') {\r\n\t\t\tproperty.type = 'object'\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t} else {\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = 10\r\n\t\t\tconsole.error('Unable to write value of type ' + type)\r\n\t\t}\r\n\r\n\t\tif (typeof key === 'string') {\r\n\t\t\twriteInlineString(key)\r\n\t\t} else if (!(key === null && (type === 'object' || type === 'array'))) { // if key is null followed by sequence, we can elide the key\r\n\t\t\twriteAsDefault(key)\r\n\t\t}\r\n\t\tif (extendedType) {\r\n\t\t\tproperty.extendedType = extendedType\r\n\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\twriteInlineString(extendedType.name)\r\n\t\t}\r\n\t\treturn property\r\n\t}\r\n\r\n\tfunction writeAsIterable(iterable) {\r\n\t\twriteToken(SEQUENCE_CODE, 15)\r\n\t\tvar iterator = iterable[Symbol.iterator]()\r\n\t\tvar arrayProperty = property\r\n\t\tproperty = arrayProperty.child || (arrayProperty.child = arrayProperty) // set the current property to the child property\r\n\t\t// write out the elements\r\n\t\tvar result\r\n\t\twhile(!(result = iterator.next()).done) {\r\n\t\t\twriters[property.code](result.value, arrayProperty)\r\n\t\t}\r\n\t\tif (property !== arrayProperty.child) {\r\n\t\t\t// TODO: This really needs to happen immediately when a property changes, to match the parsing behavior\r\n\t\t\tarrayProperty.child = property\r\n\t\t}\r\n\t\tproperty = arrayProperty // restore current property\r\n\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence\r\n\t}\r\n\r\n\tfunction writeAsArray(array, parentProperty) {\r\n\t\tif (!array) {\r\n\t\t\twriteTypedValue(array)\r\n\t\t} else if (array[targetSymbol]) {\r\n\t\t\treturn writeBlockReference(array)\r\n\t\t} else if (array.constructor === Array) { // check to make sure it is an array\r\n\t\t\tvar length = array.length\r\n\t\t\tvar needsClosing\r\n\t\t\tif (length > 11) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, OPEN_SEQUENCE) // start sequence <\r\n\t\t\t\tneedsClosing = true\r\n\t\t\t} else {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, length) // write out the header token\r\n\t\t\t}\r\n\t\t\tvar arrayProperty = property\r\n\t\t\tproperty = arrayProperty[0] // set the current property to the child property\r\n\t\t\t// check to see if needs to be reset before starting\r\n\t\t\tif (arrayProperty.resetTo < arrayProperty.length && arrayProperty.serializer != serializerId) {\r\n\t\t\t\tarrayProperty.length = arrayProperty.resetTo\r\n\t\t\t\tarrayProperty.serializer = serializerId\r\n\t\t\t}\r\n\t\t\tvar propertyIndex = 0\r\n\t\t\t// write out the elements\r\n\t\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\t\tvar value = array[i]\r\n\t\t\t\tvar type = typeof value\r\n\t\t\t\tif (type === 'object') {\r\n\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\tvar constructor = value.constructor\r\n\t\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\t\t// leave type as is\r\n\t\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvar extendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { // null\r\n\t\t\t\t\t\ttype = 'undefined' // treat null as same type as undefined, both constants\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!property) {\r\n\t\t\t\t\tif (arrayProperty.getProperty) {\r\n\t\t\t\t\t\t// a shared property\r\n\t\t\t\t\t\tproperty = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, 0)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (type === 'string' || type === 'number' || type === 'array')\r\n\t\t\t\t\t\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// default doesn't have to be written\r\n\t\t\t\t\t\t\tproperty = []\r\n\t\t\t\t\t\t\tproperty.type = type\r\n\t\t\t\t\t\t\tproperty.key = null\r\n\t\t\t\t\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tarrayProperty[0] = property\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t(extendedType && property.extendedType !== constructor)) {\r\n\t\t\t\t\tpropertyIndex = -1\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tproperty = arrayProperty[++propertyIndex]\r\n\t\t\t\t\t} while(property && ((property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t\t\t(extendedType && property.extendedType !== constructor)))\r\n\t\t\t\t\tif (property) {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\t} else if (arrayProperty.getProperty) {\r\n\t\t\t\t\t\t// a shared property\r\n\t\t\t\t\t\tproperty = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, -1)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\t\t\t\t\tarrayProperty[propertyIndex] = property\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (propertyUsed)\r\n\t\t\t\t\tpropertyUsed(property, array, serializerId, i)\r\n\t\t\t\tvar code = property.code\r\n\t\t\t\tif (code > 7) {\r\n\t\t\t\t\tif (code === 8)\r\n\t\t\t\t\t\twriteAsReferencing(value)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\twriteAsNumber(value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (code === 6) \r\n\t\t\t\t\t\twriteAsDefault(value)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\twriteAsArray(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (needsClosing) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence\r\n\t\t\t}\r\n\t\t\tproperty = arrayProperty // restore current property\r\n\t\t} else { // bail to default mode behavior\r\n\t\t\twriteTypedValue(array)\r\n\t\t}\r\n\t}\r\n\r\n\tvar blockProperty\r\n\r\n\tfunction writeBlockReference(block, writer) {\r\n\t\twriteToken(SEQUENCE_CODE, DEFERRED_REFERENCE)\r\n\t\tvar blockProperty = property\r\n\t\tvar lazyPromise = block[targetSymbol] ? {\r\n\t\t\tthen: then\r\n\t\t} : {\r\n\t\t\tthen: function(callback) {\r\n\t\t\t\treturn block.then(function(value) {\r\n\t\t\t\t\tblock = value\r\n\t\t\t\t\tthen(callback)\r\n\t\t\t\t}, function(error) {\r\n\t\t\t\t\tblock = Object.assign(new ((typeof error == 'object' && error) ? error.constructor : Error)(), {\r\n\t\t\t\t\t\tname: error && error.name, // make these enumerable so they will serialize\r\n\t\t\t\t\t\tmessage: error && error.message || error\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (!blockProperty.upgrade) {\r\n\t\t\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\t\t\twriteToken(NUMBER_CODE, ERROR_METADATA)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthen(callback)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction then(callback) {\r\n\t\t\tif (options.forBlock) {\r\n\t\t\t\t// this is used by the sizeTable serializer to record the size of each block\r\n\t\t\t\toptions.forBlock(block, blockProperty)\r\n\t\t\t} else {\r\n\t\t\t\tvar buffer = block && block[bufferSymbol] && block[bufferSymbol](blockProperty)\r\n\t\t\t\tif (buffer) {\r\n\t\t\t\t\twriteBuffer(buffer)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproperty = blockProperty\r\n\t\t\t\t\tvar lastPendingEncodings = pendingEncodings\r\n\t\t\t\t\tpendingEncodings = [] // record any nested pending encoding separately\r\n\t\t\t\t\twriteAsDefault(block) // write it out as the next block\r\n\t\t\t\t\tlastPendingEncodings.unshift.apply(lastPendingEncodings, pendingEncodings) // and splice them in front\r\n\t\t\t\t\tpendingEncodings = lastPendingEncodings\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcallback()\r\n\t\t}\r\n\t\tpendingEncodings.push(lazyPromise)\r\n\t}\r\n\r\n\tvar serializer = {\r\n\t\tserialize: function(value, sharedProperty) {\r\n\t\t\tvar buffer = value && value[bufferSymbol] && value[bufferSymbol](sharedProperty)\r\n\r\n\t\t\tif (buffer) {\r\n\t\t\t\tcharEncoder.writeBuffer(buffer)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (sharedProperty) {\r\n\t\t\t\tproperty = sharedProperty\r\n\t\t\t\twriters[property.code](value)\r\n\t\t\t} else {\r\n\t\t\t\tproperty = []\r\n\t\t\t\tproperty.key = null\r\n\t\t\t\twriteAsDefault(value)\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetSerialized: function() {\r\n\t\t\tif (pendingEncodings.length > 0) {\r\n\t\t\t\tvar promises = []\r\n\t\t\t\twhile (pendingEncodings.length > 0) {\r\n\t\t\t\t\tvar finished = false\r\n\t\t\t\t\tvar promise = pendingEncodings.shift().then(function() {\r\n\t\t\t\t\t\tfinished = true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (!finished) {\r\n\t\t\t\t\t\tpromises.push(promise)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (promises.length > 0) {\r\n\t\t\t\t\treturn Promise.all(promises).then(function() {\r\n\t\t\t\t\t\treturn serializer.getSerialized()\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (options && options.encoding === 'utf16le') {\r\n\t\t\t\treturn Buffer.from(charEncoder.getSerialized(), 'utf16le')\r\n\t\t\t}\r\n\t\t\treturn charEncoder.getSerialized()\r\n\t\t},\r\n\t\tflush: charEncoder.flush,\r\n\t\tsetOffset: charEncoder.setOffset,\r\n\t\tpendingEncodings: pendingEncodings,\r\n\t\tgetWriters: function() {\r\n\t\t\treturn {\r\n\t\t\t\twriteProperty: writeProperty,\r\n\t\t\t\twriteToken: writeToken,\r\n\t\t\t\twriteAsDefault: writeAsDefault,\r\n\t\t\t\twriteBuffer: writeBuffer\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn serializer\r\n}\r\nfunction serialize(value, options) {\r\n\tvar serializer = createSerializer(options)\r\n\tvar sharedProperty = options && options.shared\r\n\tvar buffer\r\n\tif (sharedProperty && sharedProperty.startWrite) {\r\n\t\t// record the start of each write\r\n\t\tsharedProperty.startWrite(options.avoidShareUpdate, value)\r\n\t}\r\n\tserializer.serialize(value, sharedProperty)\r\n\tbuffer = serializer.getSerialized()\r\n\tif (sharedProperty && sharedProperty.endWrite) {\r\n\t\t// record the end of each write\r\n\t\tsharedProperty.endWrite(options.avoidShareUpdate, value)\r\n\t}\r\n\tvar sizeTable = value && value[exports.sizeTableSymbol]\r\n\tif (sizeTable) {\r\n\t\tbuffer.sizeTable = sizeTable\r\n\t}\r\n\r\n\tif (options && options.lazy) {\r\n\t\treturn Buffer.concat([value[exports.sizeTableSymbol], buffer])\r\n\t}\r\n\treturn buffer\r\n}\r\nexports.serialize = serialize\r\nexports.createSerializer = createSerializer\r\nfunction browserCharEncoder() {\r\n\tvar serialized = ''\r\n\tfunction writeToken(type, number) {\r\n\t\tvar serializedToken\r\n\t\tif (number < 0x10) { // 4 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(((type << 4) | number) ^ 0x40)\r\n\t\t} else if (number < 0x400) { // 10 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 6),\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000) { // 16 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 12),\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000) { // 22 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 18),\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000000) { // 28 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 24),\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x100000000) { // 32 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 30),\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000000) { // 34 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x40000000 >>> 0),\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000000000) { // 40 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x1000000000 >>> 0),\r\n\t\t\t\t(number / 0x40000000) & 0x3f,\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000000000) { // 46 bits of number (needed for dates!)\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x40000000000 >>> 0),\r\n\t\t\t\t(number / 0x1000000000) & 0x3f,\r\n\t\t\t\t(number / 0x40000000) & 0x3f,\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else {\r\n\t\t\tthrow new Error('Too big of number')\r\n\t\t}\r\n\t\tserialized += serializedToken\r\n\t}\r\n\tfunction writeString(string) {\r\n\t\tserialized += string\r\n\t}\r\n\tfunction getSerialized() {\r\n\t\treturn serialized\r\n\t}\r\n\treturn {\r\n\t\twriteToken: writeToken,\r\n\t\twriteString: writeString,\r\n\t\t//writeBuffer,\r\n\t\tgetSerialized: getSerialized,\r\n\t\t//insertBuffer,\r\n\t\t//flush,\r\n\t\tstartSequence: function() {\r\n\t\t\twriteToken(SEQUENCE_CODE, OPEN_SEQUENCE)\r\n\t\t},\r\n\t\tendSequence: function() {\r\n\t\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE)\r\n\t\t},\r\n\t\tgetOffset: function() {// unsupported\r\n\t\t\treturn -1\r\n\t\t}\r\n\t}\r\n}\r\nvar ArrayFrom = Array.from || function(iterable, keyValue) {\r\n\tvar array = []\r\n\tvar keyValue = iterable.constructor === Map\r\n\titerable.forEach(function(key, value) {\r\n\t\tif (keyValue) {\r\n\t\t\tarray.push([value, key])\r\n\t\t} else {\r\n\t\t\tarray.push(key)\r\n\t\t}\r\n\t})\r\n\treturn array\r\n}\r\n\r\nfunction writeMap(map) {\r\n\tvar keyValues = ArrayFrom(map)\r\n\tfor (var i = 0, length = keyValues.length; i < length; i++) {\r\n\t\tvar keyValue = keyValues[i]\r\n\t\tkeyValues[i] = {\r\n\t\t\tkey: keyValue[0],\r\n\t\t\tvalue: keyValue[1]\r\n\t\t}\r\n\t}\r\n\treturn keyValues\r\n}\r\nfunction writeSet(set) {\r\n\treturn ArrayFrom(set)\r\n}\r\nfunction writeDate(date) {\r\n\treturn date.getTime()\r\n}","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","\"use strict\"\r\nvar createParser = require('./lib/parse').createParser\r\n\r\nexports.XMLHttpRequest = function() {\r\n\tvar xhr = new XMLHttpRequest()\r\n\tvar parser\r\n\tvar responseResolve\r\n\tvar responseRejected\r\n   \tvar requestResolved\r\n\txhr.addEventListener('progress', receivedData)\r\n\tvar acceptSet\r\n\tvar originalSetRequestHeader = xhr.setRequestHeader\r\n\tvar lastOffset = 0\r\n\txhr.setRequestHeader = function(name, value) {\r\n\t\tif (name.toLowerCase() == 'accept')\r\n\t\t\tacceptSet = true\r\n\t\treturn originalSetRequestHeader.call(this, name, value)\r\n\t}\r\n\tvar originalSend = xhr.send\r\n\txhr.send = function() {\r\n\t\tif (!acceptSet)\r\n\t\t\tthis.setRequestHeader('Accept', 'text/dpack;q=1,application/json;q=0.7')\r\n\t\toriginalSend.apply(this, arguments)\r\n\t}\r\n\r\n\tfunction receivedData(event) {\r\n\t\tvar sourceText = xhr.responseText\r\n\t\ttry {\r\n\t\t\tif (parser) {\r\n\t\t\t\tif (parser.onResume) {\r\n\t\t\t\t\tvar updatedData = parser.onResume(sourceText.slice(lastOffset), true, true)\r\n\t\t\t\t\txhr.responseParsed = xhr.responseParsed || updatedData\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (sourceText && /dpack/.test(xhr.getResponseHeader('Content-Type'))) {\r\n\t\t\t\t\tparser = createParser()\r\n\t\t\t\t\tparser.setSource(sourceText, 0, true)\r\n\t\t\t\t\txhr.responseParsed = parser.read()\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tlastOffset = sourceText.length\r\n\t\t} catch (error) {\r\n\t\t\tif (xhr.onerror) {\r\n\t\t\t\txhr.onerror(error)\r\n\t\t\t} else {\r\n\t\t\t\tthrow error\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\txhr.addEventListener('load', function(event) {\r\n\t\treceivedData()\r\n\t\tif (parser && parser.isPaused()) {\r\n\t\t\tthrow new Error('Unexpected end of dpack stream')\r\n\t\t}\r\n\t})\r\n\treturn xhr\r\n}\r\n"],"sourceRoot":""}