import {
  Lexer,
  Slugger
} from "./chunk-JKNEXZ5Y.js";
import "./chunk-EMTS6HMJ.js";
import "./chunk-X7HCJ7ZS.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_text,
  compute_rest_props,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onMount,
  safe_not_equal,
  setContext,
  set_data_dev,
  space,
  src_url_equal,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-PAC7UUVX.js";
import "./chunk-ZUGQ3PSC.js";
import "./chunk-CSA734CT.js";

// node_modules/svelte-markdown/src/supress-warnings.js
function supressWarnings() {
  const origWarn = console.warn;
  console.warn = (message) => {
    if (message.includes("unknown prop"))
      return;
    if (message.includes("unexpected slot"))
      return;
    origWarn(message);
  };
  onMount(() => {
    console.warn = origWarn;
  });
}

// node_modules/svelte-markdown/src/Parser.svelte
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  child_ctx[15] = i;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[15] = i;
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_if_block_1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2, create_if_block_3, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*type*/
      ctx2[0] === "table"
    )
      return 0;
    if (
      /*type*/
      ctx2[0] === "list"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(19:2) {#if renderers[type]}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*tokens*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tokens, renderers*/
      34) {
        each_value = ensure_array_like_dev(
          /*tokens*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(14:0) {#if !type}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*$$restProps*/
    ctx[6]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5][
      /*type*/
      ctx[0]
    ]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty & /*$$restProps*/
    64) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[6]
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers, type*/
      33 && switch_value !== (switch_value = /*renderers*/
      ctx2[5][
        /*type*/
        ctx2[0]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*$$restProps*/
        64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )]) : {};
        if (dirty & /*$$scope, tokens, renderers, $$restProps*/
        8388706) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(69:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4, create_else_block];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*ordered*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(51:30) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].table
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].table)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, renderers, rows, $$restProps, header*/
        8388716) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(20:4) {#if type === 'table'}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let t_value = (
    /*$$restProps*/
    ctx[6].raw + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$$restProps*/
      64 && t_value !== (t_value = /*$$restProps*/
      ctx2[6].raw + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(73:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let parser;
  let current;
  parser = new Parser({
    props: {
      tokens: (
        /*tokens*/
        ctx[1]
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(parser.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(parser.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*tokens*/
      2)
        parser_changes.tokens = /*tokens*/
        ctx2[1];
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(parser, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(71:8) {#if tokens}",
    ctx
  });
  return block;
}
function create_default_slot_11(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5, create_else_block_2];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*tokens*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_11.name,
    type: "slot",
    source: "(70:6) <svelte:component this={renderers[type]} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { ordered: (
      /*ordered*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].list
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty & /*ordered, $$restProps*/
    80) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty & /*ordered*/
        16 && { ordered: (
          /*ordered*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].list)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*ordered, $$restProps*/
        80 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*ordered*/
          16 && { ordered: (
            /*ordered*/
            ctx2[4]
          ) },
          dirty & /*$$restProps*/
          64 && get_spread_object(
            /*$$restProps*/
            ctx2[6]
          )
        ]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(60:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { ordered: (
      /*ordered*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].list
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty & /*ordered, $$restProps*/
    80) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty & /*ordered*/
        16 && { ordered: (
          /*ordered*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].list)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*ordered, $$restProps*/
        80 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*ordered*/
          16 && { ordered: (
            /*ordered*/
            ctx2[4]
          ) },
          dirty & /*$$restProps*/
          64 && get_spread_object(
            /*$$restProps*/
            ctx2[6]
          )
        ]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(52:6) {#if ordered}",
    ctx
  });
  return block;
}
function create_default_slot_10(ctx) {
  let parser;
  let t;
  let current;
  parser = new Parser({
    props: {
      tokens: (
        /*item*/
        ctx[18].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(parser.$$.fragment);
      t = space();
    },
    l: function claim(nodes) {
      claim_component(parser.$$.fragment, nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(parser, target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*$$restProps*/
      64)
        parser_changes.tokens = /*item*/
        ctx2[18].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(parser, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10.name,
    type: "slot",
    source: "(63:12) <svelte:component this={renderers.unorderedlistitem || renderers.listitem} {...item}>",
    ctx
  });
  return block;
}
function create_each_block_5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*item*/
    ctx[18]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].unorderedlistitem || /*renderers*/
    ctx[5].listitem
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty & /*$$restProps*/
    64) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*item*/
        ctx2[18]
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].unorderedlistitem || /*renderers*/
      ctx2[5].listitem)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*$$restProps*/
        64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*item*/
          ctx2[18]
        )]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_5.name,
    type: "each",
    source: "(62:10) {#each $$restProps.items as item}",
    ctx
  });
  return block;
}
function create_default_slot_9(ctx) {
  let each_1_anchor;
  let current;
  let each_value_5 = ensure_array_like_dev(
    /*$$restProps*/
    ctx[6].items
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps*/
      96) {
        each_value_5 = ensure_array_like_dev(
          /*$$restProps*/
          ctx2[6].items
        );
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_5.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_5.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9.name,
    type: "slot",
    source: "(61:8) <svelte:component this={renderers.list} {ordered} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_default_slot_8(ctx) {
  let parser;
  let t;
  let current;
  parser = new Parser({
    props: {
      tokens: (
        /*item*/
        ctx[18].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(parser.$$.fragment);
      t = space();
    },
    l: function claim(nodes) {
      claim_component(parser.$$.fragment, nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(parser, target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*$$restProps*/
      64)
        parser_changes.tokens = /*item*/
        ctx2[18].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(parser, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8.name,
    type: "slot",
    source: "(55:12) <svelte:component this={renderers.orderedlistitem || renderers.listitem} {...item}>",
    ctx
  });
  return block;
}
function create_each_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*item*/
    ctx[18]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].orderedlistitem || /*renderers*/
    ctx[5].listitem
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty & /*$$restProps*/
    64) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*item*/
        ctx2[18]
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].orderedlistitem || /*renderers*/
      ctx2[5].listitem)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*$$restProps*/
        64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*item*/
          ctx2[18]
        )]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(54:10) {#each $$restProps.items as item}",
    ctx
  });
  return block;
}
function create_default_slot_7(ctx) {
  let each_1_anchor;
  let current;
  let each_value_4 = ensure_array_like_dev(
    /*$$restProps*/
    ctx[6].items
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps*/
      96) {
        each_value_4 = ensure_array_like_dev(
          /*$$restProps*/
          ctx2[6].items
        );
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_4.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_4.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7.name,
    type: "slot",
    source: "(53:8) <svelte:component this={renderers.list} {ordered} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_default_slot_6(ctx) {
  let parser;
  let t;
  let current;
  parser = new Parser({
    props: {
      tokens: (
        /*headerItem*/
        ctx[16].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(parser.$$.fragment);
      t = space();
    },
    l: function claim(nodes) {
      claim_component(parser.$$.fragment, nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(parser, target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*header*/
      4)
        parser_changes.tokens = /*headerItem*/
        ctx2[16].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(parser, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: "(25:14) <svelte:component                 this={renderers.tablecell}                 header={true}                 align={$$restProps.align[i] || 'center'}                 >",
    ctx
  });
  return block;
}
function create_each_block_3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablecell
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        header: true,
        align: (
          /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center"
        ),
        $$slots: { default: [create_default_slot_6] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablecell)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$restProps*/
        64)
          switch_instance_changes.align = /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center";
        if (dirty & /*$$scope, header, renderers*/
        8388644) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(24:12) {#each header as headerItem, i}",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let each_1_anchor;
  let current;
  let each_value_3 = ensure_array_like_dev(
    /*header*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps, header*/
      100) {
        each_value_3 = ensure_array_like_dev(
          /*header*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(23:10) <svelte:component this={renderers.tablerow}>",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablerow
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_5] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablerow)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, header, renderers, $$restProps*/
        8388708) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(22:8) <svelte:component this={renderers.tablehead}>",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let parser;
  let current;
  parser = new Parser({
    props: {
      tokens: (
        /*cells*/
        ctx[13].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(parser.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(parser.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*rows*/
      8)
        parser_changes.tokens = /*cells*/
        ctx2[13].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(parser, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(39:16) <svelte:component                   this={renderers.tablecell}                   header={false}                   align={$$restProps.align[i] || 'center'}                   >",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablecell
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        header: false,
        align: (
          /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center"
        ),
        $$slots: { default: [create_default_slot_3] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablecell)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$restProps*/
        64)
          switch_instance_changes.align = /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center";
        if (dirty & /*$$scope, rows, renderers*/
        8388648) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(38:14) {#each row as cells, i}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let t;
  let current;
  let each_value_2 = ensure_array_like_dev(
    /*row*/
    ctx[10]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps, rows*/
      104) {
        each_value_2 = ensure_array_like_dev(
          /*row*/
          ctx2[10]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(t.parentNode, t);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(37:12) <svelte:component this={renderers.tablerow}>",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablerow
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_2] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablerow)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, rows, renderers, $$restProps*/
        8388712) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(36:10) {#each rows as row}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*rows*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers, rows, $$restProps*/
      104) {
        each_value_1 = ensure_array_like_dev(
          /*rows*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(35:8) <svelte:component this={renderers.tablebody}>",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let switch_instance0;
  let t;
  let switch_instance1;
  let switch_instance1_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablehead
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_4] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  var switch_value_1 = (
    /*renderers*/
    ctx[5].tablebody
  );
  function switch_props_1(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_1] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t = space();
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      switch_instance1_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance0)
        claim_component(switch_instance0.$$.fragment, nodes);
      t = claim_space(nodes);
      if (switch_instance1)
        claim_component(switch_instance1.$$.fragment, nodes);
      switch_instance1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance0)
        mount_component(switch_instance0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, target, anchor);
      insert_hydration_dev(target, switch_instance1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablehead)) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, t.parentNode, t);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        const switch_instance0_changes = {};
        if (dirty & /*$$scope, renderers, header, $$restProps*/
        8388708) {
          switch_instance0_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance0.$set(switch_instance0_changes);
      }
      if (dirty & /*renderers*/
      32 && switch_value_1 !== (switch_value_1 = /*renderers*/
      ctx2[5].tablebody)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx2, dirty));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, switch_instance1_anchor.parentNode, switch_instance1_anchor);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        const switch_instance1_changes = {};
        if (dirty & /*$$scope, rows, renderers, $$restProps*/
        8388712) {
          switch_instance1_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance1.$set(switch_instance1_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(switch_instance1_anchor);
      }
      if (switch_instance0)
        destroy_component(switch_instance0, detaching);
      if (switch_instance1)
        destroy_component(switch_instance1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(21:6) <svelte:component this={renderers.table}>",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let parser;
  let current;
  const parser_spread_levels = [
    /*token*/
    ctx[7],
    { renderers: (
      /*renderers*/
      ctx[5]
    ) }
  ];
  let parser_props = {};
  for (let i = 0; i < parser_spread_levels.length; i += 1) {
    parser_props = assign(parser_props, parser_spread_levels[i]);
  }
  parser = new Parser({ props: parser_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(parser.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(parser.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const parser_changes = dirty & /*tokens, renderers*/
      34 ? get_spread_update(parser_spread_levels, [
        dirty & /*tokens*/
        2 && get_spread_object(
          /*token*/
          ctx2[7]
        ),
        dirty & /*renderers*/
        32 && { renderers: (
          /*renderers*/
          ctx2[5]
        ) }
      ]) : {};
      parser.$set(parser_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(parser, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(15:2) {#each tokens as token}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_if_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*type*/
    ctx2[0])
      return 0;
    if (
      /*renderers*/
      ctx2[5][
        /*type*/
        ctx2[0]
      ]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["type", "tokens", "header", "rows", "ordered", "renderers"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Parser", slots, []);
  let { type = void 0 } = $$props;
  let { tokens = void 0 } = $$props;
  let { header = void 0 } = $$props;
  let { rows = void 0 } = $$props;
  let { ordered = false } = $$props;
  let { renderers } = $$props;
  supressWarnings();
  $$self.$$.on_mount.push(function() {
    if (renderers === void 0 && !("renderers" in $$props || $$self.$$.bound[$$self.$$.props["renderers"]])) {
      console.warn("<Parser> was created without expected prop 'renderers'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(0, type = $$new_props.type);
    if ("tokens" in $$new_props)
      $$invalidate(1, tokens = $$new_props.tokens);
    if ("header" in $$new_props)
      $$invalidate(2, header = $$new_props.header);
    if ("rows" in $$new_props)
      $$invalidate(3, rows = $$new_props.rows);
    if ("ordered" in $$new_props)
      $$invalidate(4, ordered = $$new_props.ordered);
    if ("renderers" in $$new_props)
      $$invalidate(5, renderers = $$new_props.renderers);
  };
  $$self.$capture_state = () => ({
    supressWarnings,
    type,
    tokens,
    header,
    rows,
    ordered,
    renderers
  });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props)
      $$invalidate(0, type = $$new_props.type);
    if ("tokens" in $$props)
      $$invalidate(1, tokens = $$new_props.tokens);
    if ("header" in $$props)
      $$invalidate(2, header = $$new_props.header);
    if ("rows" in $$props)
      $$invalidate(3, rows = $$new_props.rows);
    if ("ordered" in $$props)
      $$invalidate(4, ordered = $$new_props.ordered);
    if ("renderers" in $$props)
      $$invalidate(5, renderers = $$new_props.renderers);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [type, tokens, header, rows, ordered, renderers, $$restProps];
}
var Parser = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      type: 0,
      tokens: 1,
      header: 2,
      rows: 3,
      ordered: 4,
      renderers: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Parser",
      options,
      id: create_fragment.name
    });
  }
  get type() {
    throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tokens() {
    throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tokens(value) {
    throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ordered() {
    throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ordered(value) {
    throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderers() {
    throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderers(value) {
    throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Parser_default = Parser;

// node_modules/svelte-markdown/src/context.js
var key = {};

// node_modules/svelte-markdown/src/renderers/Heading.svelte
var file = "node_modules/svelte-markdown/src/renderers/Heading.svelte";
function create_else_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*raw*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*raw*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*raw*/
      2)
        set_data_dev(
          t,
          /*raw*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(28:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let h6;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      h6 = element("h6");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h6 = claim_element(nodes, "H6", { id: true });
      var h6_nodes = children(h6);
      if (default_slot)
        default_slot.l(h6_nodes);
      h6_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        h6,
        "id",
        /*id*/
        ctx[2]
      );
      add_location(h6, file, 26, 2, 596);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h6, anchor);
      if (default_slot) {
        default_slot.m(h6, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          h6,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h6);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(26:22) ",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let h5;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      h5 = element("h5");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h5 = claim_element(nodes, "H5", { id: true });
      var h5_nodes = children(h5);
      if (default_slot)
        default_slot.l(h5_nodes);
      h5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        h5,
        "id",
        /*id*/
        ctx[2]
      );
      add_location(h5, file, 24, 2, 543);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h5, anchor);
      if (default_slot) {
        default_slot.m(h5, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          h5,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h5);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(24:22) ",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let h4;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      h4 = element("h4");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h4 = claim_element(nodes, "H4", { id: true });
      var h4_nodes = children(h4);
      if (default_slot)
        default_slot.l(h4_nodes);
      h4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        h4,
        "id",
        /*id*/
        ctx[2]
      );
      add_location(h4, file, 22, 2, 490);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h4, anchor);
      if (default_slot) {
        default_slot.m(h4, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          h4,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h4);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(22:22) ",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let h3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h3 = claim_element(nodes, "H3", { id: true });
      var h3_nodes = children(h3);
      if (default_slot)
        default_slot.l(h3_nodes);
      h3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        h3,
        "id",
        /*id*/
        ctx[2]
      );
      add_location(h3, file, 20, 2, 437);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          h3,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h3);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(20:22) ",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let h2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      h2 = element("h2");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", { id: true });
      var h2_nodes = children(h2);
      if (default_slot)
        default_slot.l(h2_nodes);
      h2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        h2,
        "id",
        /*id*/
        ctx[2]
      );
      add_location(h2, file, 18, 2, 384);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      if (default_slot) {
        default_slot.m(h2, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          h2,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(18:22) ",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let h1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      h1 = element("h1");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h1 = claim_element(nodes, "H1", { id: true });
      var h1_nodes = children(h1);
      if (default_slot)
        default_slot.l(h1_nodes);
      h1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        h1,
        "id",
        /*id*/
        ctx[2]
      );
      add_location(h1, file, 16, 2, 331);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h1, anchor);
      if (default_slot) {
        default_slot.m(h1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          h1,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h1);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(16:0) {#if depth === 1}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block2,
    create_if_block_12,
    create_if_block_22,
    create_if_block_32,
    create_if_block_42,
    create_if_block_52,
    create_else_block2
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*depth*/
      ctx2[0] === 1
    )
      return 0;
    if (
      /*depth*/
      ctx2[0] === 2
    )
      return 1;
    if (
      /*depth*/
      ctx2[0] === 3
    )
      return 2;
    if (
      /*depth*/
      ctx2[0] === 4
    )
      return 3;
    if (
      /*depth*/
      ctx2[0] === 5
    )
      return 4;
    if (
      /*depth*/
      ctx2[0] === 6
    )
      return 5;
    return 6;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let id;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Heading", slots, ["default"]);
  let { depth } = $$props;
  let { raw } = $$props;
  let { text: text2 } = $$props;
  const { slug, getOptions } = getContext(key);
  const options = getOptions();
  $$self.$$.on_mount.push(function() {
    if (depth === void 0 && !("depth" in $$props || $$self.$$.bound[$$self.$$.props["depth"]])) {
      console.warn("<Heading> was created without expected prop 'depth'");
    }
    if (raw === void 0 && !("raw" in $$props || $$self.$$.bound[$$self.$$.props["raw"]])) {
      console.warn("<Heading> was created without expected prop 'raw'");
    }
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<Heading> was created without expected prop 'text'");
    }
  });
  const writable_props = ["depth", "raw", "text"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Heading> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("depth" in $$props2)
      $$invalidate(0, depth = $$props2.depth);
    if ("raw" in $$props2)
      $$invalidate(1, raw = $$props2.raw);
    if ("text" in $$props2)
      $$invalidate(3, text2 = $$props2.text);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    key,
    depth,
    raw,
    text: text2,
    slug,
    getOptions,
    options,
    id
  });
  $$self.$inject_state = ($$props2) => {
    if ("depth" in $$props2)
      $$invalidate(0, depth = $$props2.depth);
    if ("raw" in $$props2)
      $$invalidate(1, raw = $$props2.raw);
    if ("text" in $$props2)
      $$invalidate(3, text2 = $$props2.text);
    if ("id" in $$props2)
      $$invalidate(2, id = $$props2.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*text*/
    8) {
      $:
        $$invalidate(2, id = options.headerIds ? options.headerPrefix + slug(text2) : void 0);
    }
  };
  return [depth, raw, id, text2, $$scope, slots];
}
var Heading = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { depth: 0, raw: 1, text: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Heading",
      options,
      id: create_fragment2.name
    });
  }
  get depth() {
    throw new Error("<Heading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set depth(value) {
    throw new Error("<Heading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raw() {
    throw new Error("<Heading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raw(value) {
    throw new Error("<Heading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Heading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Heading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Heading_default = Heading;

// node_modules/svelte-markdown/src/renderers/Paragraph.svelte
var file2 = "node_modules/svelte-markdown/src/renderers/Paragraph.svelte";
function create_fragment3(ctx) {
  let p;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file2, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Paragraph", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Paragraph> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Paragraph = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Paragraph",
      options,
      id: create_fragment3.name
    });
  }
};
var Paragraph_default = Paragraph;

// node_modules/svelte-markdown/src/renderers/Text.svelte
function create_fragment4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  let { text: text2 } = $$props;
  text2;
  let { raw } = $$props;
  raw;
  $$self.$$.on_mount.push(function() {
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<Text> was created without expected prop 'text'");
    }
    if (raw === void 0 && !("raw" in $$props || $$self.$$.bound[$$self.$$.props["raw"]])) {
      console.warn("<Text> was created without expected prop 'raw'");
    }
  });
  const writable_props = ["text", "raw"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Text> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("raw" in $$props2)
      $$invalidate(1, raw = $$props2.raw);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ text: text2, raw });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("raw" in $$props2)
      $$invalidate(1, raw = $$props2.raw);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [text2, raw, $$scope, slots];
}
var Text = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { text: 0, raw: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment4.name
    });
  }
  get text() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raw() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raw(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text;

// node_modules/svelte-markdown/src/renderers/Image.svelte
var file3 = "node_modules/svelte-markdown/src/renderers/Image.svelte";
function create_fragment5(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { src: true, title: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = /*href*/
      ctx[0]))
        attr_dev(img, "src", img_src_value);
      attr_dev(
        img,
        "title",
        /*title*/
        ctx[1]
      );
      attr_dev(
        img,
        "alt",
        /*text*/
        ctx[2]
      );
      add_location(img, file3, 6, 0, 97);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*href*/
      1 && !src_url_equal(img.src, img_src_value = /*href*/
      ctx2[0])) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty & /*title*/
      2) {
        attr_dev(
          img,
          "title",
          /*title*/
          ctx2[1]
        );
      }
      if (dirty & /*text*/
      4) {
        attr_dev(
          img,
          "alt",
          /*text*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { href = "" } = $$props;
  let { title = void 0 } = $$props;
  let { text: text2 = "" } = $$props;
  const writable_props = ["href", "title", "text"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Image> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("text" in $$props2)
      $$invalidate(2, text2 = $$props2.text);
  };
  $$self.$capture_state = () => ({ href, title, text: text2 });
  $$self.$inject_state = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("text" in $$props2)
      $$invalidate(2, text2 = $$props2.text);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [href, title, text2];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { href: 0, title: 1, text: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment5.name
    });
  }
  get href() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/svelte-markdown/src/renderers/Link.svelte
var file4 = "node_modules/svelte-markdown/src/renderers/Link.svelte";
function create_fragment6(ctx) {
  let a;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, title: true });
      var a_nodes = children(a);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[0]
      );
      attr_dev(
        a,
        "title",
        /*title*/
        ctx[1]
      );
      add_location(a, file4, 5, 0, 74);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*href*/
      1) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*title*/
      2) {
        attr_dev(
          a,
          "title",
          /*title*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Link", slots, ["default"]);
  let { href = "" } = $$props;
  let { title = void 0 } = $$props;
  const writable_props = ["href", "title"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Link> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ href, title });
  $$self.$inject_state = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [href, title, $$scope, slots];
}
var Link = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { href: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link",
      options,
      id: create_fragment6.name
    });
  }
  get href() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Link_default = Link;

// node_modules/svelte-markdown/src/renderers/Em.svelte
var file5 = "node_modules/svelte-markdown/src/renderers/Em.svelte";
function create_fragment7(ctx) {
  let em;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      em = element("em");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      em = claim_element(nodes, "EM", {});
      var em_nodes = children(em);
      if (default_slot)
        default_slot.l(em_nodes);
      em_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(em, file5, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, em, anchor);
      if (default_slot) {
        default_slot.m(em, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(em);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Em", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Em> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Em = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Em",
      options,
      id: create_fragment7.name
    });
  }
};
var Em_default = Em;

// node_modules/svelte-markdown/src/renderers/Del.svelte
var file6 = "node_modules/svelte-markdown/src/renderers/Del.svelte";
function create_fragment8(ctx) {
  let del;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      del = element("del");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      del = claim_element(nodes, "DEL", {});
      var del_nodes = children(del);
      if (default_slot)
        default_slot.l(del_nodes);
      del_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(del, file6, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, del, anchor);
      if (default_slot) {
        default_slot.m(del, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(del);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Del", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Del> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Del = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Del",
      options,
      id: create_fragment8.name
    });
  }
};
var Del_default = Del;

// node_modules/svelte-markdown/src/renderers/Codespan.svelte
var file7 = "node_modules/svelte-markdown/src/renderers/Codespan.svelte";
function create_fragment9(ctx) {
  let code;
  let t_value = (
    /*raw*/
    ctx[0].replace(/`/g, "") + ""
  );
  let t;
  const block = {
    c: function create() {
      code = element("code");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      code = claim_element(nodes, "CODE", {});
      var code_nodes = children(code);
      t = claim_text(code_nodes, t_value);
      code_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(code, file7, 4, 0, 37);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, code, anchor);
      append_hydration_dev(code, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*raw*/
      1 && t_value !== (t_value = /*raw*/
      ctx2[0].replace(/`/g, "") + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(code);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Codespan", slots, []);
  let { raw } = $$props;
  $$self.$$.on_mount.push(function() {
    if (raw === void 0 && !("raw" in $$props || $$self.$$.bound[$$self.$$.props["raw"]])) {
      console.warn("<Codespan> was created without expected prop 'raw'");
    }
  });
  const writable_props = ["raw"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Codespan> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("raw" in $$props2)
      $$invalidate(0, raw = $$props2.raw);
  };
  $$self.$capture_state = () => ({ raw });
  $$self.$inject_state = ($$props2) => {
    if ("raw" in $$props2)
      $$invalidate(0, raw = $$props2.raw);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [raw];
}
var Codespan = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { raw: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Codespan",
      options,
      id: create_fragment9.name
    });
  }
  get raw() {
    throw new Error("<Codespan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raw(value) {
    throw new Error("<Codespan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Codespan_default = Codespan;

// node_modules/svelte-markdown/src/renderers/Strong.svelte
var file8 = "node_modules/svelte-markdown/src/renderers/Strong.svelte";
function create_fragment10(ctx) {
  let strong;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      strong = element("strong");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      strong = claim_element(nodes, "STRONG", {});
      var strong_nodes = children(strong);
      if (default_slot)
        default_slot.l(strong_nodes);
      strong_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(strong, file8, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, strong, anchor);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(strong);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Strong", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Strong> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Strong = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Strong",
      options,
      id: create_fragment10.name
    });
  }
};
var Strong_default = Strong;

// node_modules/svelte-markdown/src/renderers/Table.svelte
var file9 = "node_modules/svelte-markdown/src/renderers/Table.svelte";
function create_fragment11(ctx) {
  let table;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      table = element("table");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", {});
      var table_nodes = children(table);
      if (default_slot)
        default_slot.l(table_nodes);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(table, file9, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      if (default_slot) {
        default_slot.m(table, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(table);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Table> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment11.name
    });
  }
};
var Table_default = Table;

// node_modules/svelte-markdown/src/renderers/TableHead.svelte
var file10 = "node_modules/svelte-markdown/src/renderers/TableHead.svelte";
function create_fragment12(ctx) {
  let thead;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      thead = element("thead");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      thead = claim_element(nodes, "THEAD", {});
      var thead_nodes = children(thead);
      if (default_slot)
        default_slot.l(thead_nodes);
      thead_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(thead, file10, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, thead, anchor);
      if (default_slot) {
        default_slot.m(thead, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(thead);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableHead", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<TableHead> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var TableHead = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableHead",
      options,
      id: create_fragment12.name
    });
  }
};
var TableHead_default = TableHead;

// node_modules/svelte-markdown/src/renderers/TableBody.svelte
var file11 = "node_modules/svelte-markdown/src/renderers/TableBody.svelte";
function create_fragment13(ctx) {
  let tbody;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      tbody = element("tbody");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      tbody = claim_element(nodes, "TBODY", {});
      var tbody_nodes = children(tbody);
      if (default_slot)
        default_slot.l(tbody_nodes);
      tbody_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tbody, file11, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tbody, anchor);
      if (default_slot) {
        default_slot.m(tbody, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tbody);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableBody", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<TableBody> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var TableBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableBody",
      options,
      id: create_fragment13.name
    });
  }
};
var TableBody_default = TableBody;

// node_modules/svelte-markdown/src/renderers/TableRow.svelte
var file12 = "node_modules/svelte-markdown/src/renderers/TableRow.svelte";
function create_fragment14(ctx) {
  let tr;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      if (default_slot)
        default_slot.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file12, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableRow", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<TableRow> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var TableRow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableRow",
      options,
      id: create_fragment14.name
    });
  }
};
var TableRow_default = TableRow;

// node_modules/svelte-markdown/src/renderers/TableCell.svelte
var file13 = "node_modules/svelte-markdown/src/renderers/TableCell.svelte";
function create_else_block3(ctx) {
  let td;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { align: true });
      var td_nodes = children(td);
      if (default_slot)
        default_slot.l(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        td,
        "align",
        /*align*/
        ctx[1]
      );
      add_location(td, file13, 8, 2, 115);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*align*/
      2) {
        attr_dev(
          td,
          "align",
          /*align*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(8:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let th;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      th = element("th");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { align: true });
      var th_nodes = children(th);
      if (default_slot)
        default_slot.l(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        th,
        "align",
        /*align*/
        ctx[1]
      );
      add_location(th, file13, 6, 2, 74);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      if (default_slot) {
        default_slot.m(th, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*align*/
      2) {
        attr_dev(
          th,
          "align",
          /*align*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(6:0) {#if header}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*header*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableCell", slots, ["default"]);
  let { header } = $$props;
  let { align } = $$props;
  $$self.$$.on_mount.push(function() {
    if (header === void 0 && !("header" in $$props || $$self.$$.bound[$$self.$$.props["header"]])) {
      console.warn("<TableCell> was created without expected prop 'header'");
    }
    if (align === void 0 && !("align" in $$props || $$self.$$.bound[$$self.$$.props["align"]])) {
      console.warn("<TableCell> was created without expected prop 'align'");
    }
  });
  const writable_props = ["header", "align"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<TableCell> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("header" in $$props2)
      $$invalidate(0, header = $$props2.header);
    if ("align" in $$props2)
      $$invalidate(1, align = $$props2.align);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ header, align });
  $$self.$inject_state = ($$props2) => {
    if ("header" in $$props2)
      $$invalidate(0, header = $$props2.header);
    if ("align" in $$props2)
      $$invalidate(1, align = $$props2.align);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [header, align, $$scope, slots];
}
var TableCell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { header: 0, align: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableCell",
      options,
      id: create_fragment15.name
    });
  }
  get header() {
    throw new Error("<TableCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<TableCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<TableCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<TableCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableCell_default = TableCell;

// node_modules/svelte-markdown/src/renderers/List.svelte
var file14 = "node_modules/svelte-markdown/src/renderers/List.svelte";
function create_else_block4(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(ul, file14, 8, 2, 117);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(8:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let ol;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ol = claim_element(nodes, "OL", { start: true });
      var ol_nodes = children(ol);
      if (default_slot)
        default_slot.l(ol_nodes);
      ol_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        ol,
        "start",
        /*start*/
        ctx[1]
      );
      add_location(ol, file14, 6, 2, 76);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ol, anchor);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*start*/
      2) {
        attr_dev(
          ol,
          "start",
          /*start*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ol);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(6:0) {#if ordered}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*ordered*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List", slots, ["default"]);
  let { ordered } = $$props;
  let { start } = $$props;
  $$self.$$.on_mount.push(function() {
    if (ordered === void 0 && !("ordered" in $$props || $$self.$$.bound[$$self.$$.props["ordered"]])) {
      console.warn("<List> was created without expected prop 'ordered'");
    }
    if (start === void 0 && !("start" in $$props || $$self.$$.bound[$$self.$$.props["start"]])) {
      console.warn("<List> was created without expected prop 'start'");
    }
  });
  const writable_props = ["ordered", "start"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<List> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("ordered" in $$props2)
      $$invalidate(0, ordered = $$props2.ordered);
    if ("start" in $$props2)
      $$invalidate(1, start = $$props2.start);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ ordered, start });
  $$self.$inject_state = ($$props2) => {
    if ("ordered" in $$props2)
      $$invalidate(0, ordered = $$props2.ordered);
    if ("start" in $$props2)
      $$invalidate(1, start = $$props2.start);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ordered, start, $$scope, slots];
}
var List = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { ordered: 0, start: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List",
      options,
      id: create_fragment16.name
    });
  }
  get ordered() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ordered(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get start() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set start(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var List_default = List;

// node_modules/svelte-markdown/src/renderers/ListItem.svelte
var file15 = "node_modules/svelte-markdown/src/renderers/ListItem.svelte";
function create_fragment17(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      if (default_slot)
        default_slot.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(li, file15, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListItem", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<ListItem> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ListItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListItem",
      options,
      id: create_fragment17.name
    });
  }
};
var ListItem_default = ListItem;

// node_modules/svelte-markdown/src/renderers/Hr.svelte
var file16 = "node_modules/svelte-markdown/src/renderers/Hr.svelte";
function create_fragment18(ctx) {
  let hr;
  const block = {
    c: function create() {
      hr = element("hr");
      this.h();
    },
    l: function claim(nodes) {
      hr = claim_element(nodes, "HR", {});
      this.h();
    },
    h: function hydrate() {
      add_location(hr, file16, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, hr, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(hr);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Hr", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Hr> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Hr = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Hr",
      options,
      id: create_fragment18.name
    });
  }
};
var Hr_default = Hr;

// node_modules/svelte-markdown/src/renderers/Html.svelte
function create_fragment19(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*text*/
        ctx[0],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*text*/
      1)
        html_tag.p(
          /*text*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Html", slots, []);
  let { text: text2 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<Html> was created without expected prop 'text'");
    }
  });
  const writable_props = ["text"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Html> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
  };
  $$self.$capture_state = () => ({ text: text2 });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [text2];
}
var Html = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { text: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Html",
      options,
      id: create_fragment19.name
    });
  }
  get text() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Html_default = Html;

// node_modules/svelte-markdown/src/renderers/Blockquote.svelte
var file17 = "node_modules/svelte-markdown/src/renderers/Blockquote.svelte";
function create_fragment20(ctx) {
  let blockquote;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      blockquote = element("blockquote");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      blockquote = claim_element(nodes, "BLOCKQUOTE", {});
      var blockquote_nodes = children(blockquote);
      if (default_slot)
        default_slot.l(blockquote_nodes);
      blockquote_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(blockquote, file17, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, blockquote, anchor);
      if (default_slot) {
        default_slot.m(blockquote, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(blockquote);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Blockquote", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Blockquote> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Blockquote = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Blockquote",
      options,
      id: create_fragment20.name
    });
  }
};
var Blockquote_default = Blockquote;

// node_modules/svelte-markdown/src/renderers/Code.svelte
var file18 = "node_modules/svelte-markdown/src/renderers/Code.svelte";
function create_fragment21(ctx) {
  let pre;
  let code;
  let t;
  const block = {
    c: function create() {
      pre = element("pre");
      code = element("code");
      t = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      pre = claim_element(nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      code = claim_element(pre_nodes, "CODE", {});
      var code_nodes = children(code);
      t = claim_text(
        code_nodes,
        /*text*/
        ctx[1]
      );
      code_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(code, file18, 5, 18, 74);
      attr_dev(
        pre,
        "class",
        /*lang*/
        ctx[0]
      );
      add_location(pre, file18, 5, 0, 56);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, pre, anchor);
      append_hydration_dev(pre, code);
      append_hydration_dev(code, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*text*/
      2)
        set_data_dev(
          t,
          /*text*/
          ctx2[1]
        );
      if (dirty & /*lang*/
      1) {
        attr_dev(
          pre,
          "class",
          /*lang*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(pre);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Code", slots, []);
  let { lang } = $$props;
  let { text: text2 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (lang === void 0 && !("lang" in $$props || $$self.$$.bound[$$self.$$.props["lang"]])) {
      console.warn("<Code> was created without expected prop 'lang'");
    }
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<Code> was created without expected prop 'text'");
    }
  });
  const writable_props = ["lang", "text"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Code> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("lang" in $$props2)
      $$invalidate(0, lang = $$props2.lang);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
  };
  $$self.$capture_state = () => ({ lang, text: text2 });
  $$self.$inject_state = ($$props2) => {
    if ("lang" in $$props2)
      $$invalidate(0, lang = $$props2.lang);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [lang, text2];
}
var Code = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { lang: 0, text: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Code",
      options,
      id: create_fragment21.name
    });
  }
  get lang() {
    throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lang(value) {
    throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Code_default = Code;

// node_modules/svelte-markdown/src/renderers/Br.svelte
var file19 = "node_modules/svelte-markdown/src/renderers/Br.svelte";
function create_fragment22(ctx) {
  let br;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      br = element("br");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      br = claim_element(nodes, "BR", {});
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      add_location(br, file19, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, br, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(br);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Br", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Br> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Br = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Br",
      options,
      id: create_fragment22.name
    });
  }
};
var Br_default = Br;

// node_modules/svelte-markdown/src/markdown-parser.js
var defaultRenderers = {
  heading: Heading_default,
  paragraph: Paragraph_default,
  text: Text_default,
  image: Image_default,
  link: Link_default,
  em: Em_default,
  strong: Strong_default,
  codespan: Codespan_default,
  del: Del_default,
  table: Table_default,
  tablehead: TableHead_default,
  tablebody: TableBody_default,
  tablerow: TableRow_default,
  tablecell: TableCell_default,
  list: List_default,
  orderedlistitem: null,
  unorderedlistitem: null,
  listitem: ListItem_default,
  hr: Hr_default,
  html: Html_default,
  blockquote: Blockquote_default,
  code: Code_default,
  br: Br_default
};
var defaultOptions = {
  baseUrl: null,
  breaks: false,
  gfm: true,
  headerIds: true,
  headerPrefix: "",
  highlight: null,
  langPrefix: "language-",
  mangle: true,
  pedantic: false,
  renderer: null,
  sanitize: false,
  sanitizer: null,
  silent: false,
  smartLists: false,
  smartypants: false,
  tokenizer: null,
  xhtml: false
};

// node_modules/svelte-markdown/src/SvelteMarkdown.svelte
function create_fragment23(ctx) {
  let parser;
  let current;
  parser = new Parser_default({
    props: {
      tokens: (
        /*tokens*/
        ctx[0]
      ),
      renderers: (
        /*combinedRenderers*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(parser.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(parser.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const parser_changes = {};
      if (dirty & /*tokens*/
      1)
        parser_changes.tokens = /*tokens*/
        ctx2[0];
      if (dirty & /*combinedRenderers*/
      2)
        parser_changes.renderers = /*combinedRenderers*/
        ctx2[1];
      parser.$set(parser_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(parser, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let preprocessed;
  let slugger;
  let combinedOptions;
  let combinedRenderers;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteMarkdown", slots, []);
  let { source = [] } = $$props;
  let { renderers = {} } = $$props;
  let { options = {} } = $$props;
  let { isInline = false } = $$props;
  const dispatch = createEventDispatcher();
  let tokens;
  let lexer;
  let mounted;
  setContext(key, {
    slug: (val) => slugger ? slugger.slug(val) : "",
    getOptions: () => combinedOptions
  });
  onMount(() => {
    $$invalidate(7, mounted = true);
  });
  const writable_props = ["source", "renderers", "options", "isInline"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<SvelteMarkdown> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("source" in $$props2)
      $$invalidate(2, source = $$props2.source);
    if ("renderers" in $$props2)
      $$invalidate(3, renderers = $$props2.renderers);
    if ("options" in $$props2)
      $$invalidate(4, options = $$props2.options);
    if ("isInline" in $$props2)
      $$invalidate(5, isInline = $$props2.isInline);
  };
  $$self.$capture_state = () => ({
    setContext,
    createEventDispatcher,
    onMount,
    Parser: Parser_default,
    Lexer,
    Slugger,
    defaultOptions,
    defaultRenderers,
    key,
    source,
    renderers,
    options,
    isInline,
    dispatch,
    tokens,
    lexer,
    mounted,
    preprocessed,
    combinedOptions,
    slugger,
    combinedRenderers
  });
  $$self.$inject_state = ($$props2) => {
    if ("source" in $$props2)
      $$invalidate(2, source = $$props2.source);
    if ("renderers" in $$props2)
      $$invalidate(3, renderers = $$props2.renderers);
    if ("options" in $$props2)
      $$invalidate(4, options = $$props2.options);
    if ("isInline" in $$props2)
      $$invalidate(5, isInline = $$props2.isInline);
    if ("tokens" in $$props2)
      $$invalidate(0, tokens = $$props2.tokens);
    if ("lexer" in $$props2)
      $$invalidate(6, lexer = $$props2.lexer);
    if ("mounted" in $$props2)
      $$invalidate(7, mounted = $$props2.mounted);
    if ("preprocessed" in $$props2)
      $$invalidate(8, preprocessed = $$props2.preprocessed);
    if ("combinedOptions" in $$props2)
      $$invalidate(9, combinedOptions = $$props2.combinedOptions);
    if ("slugger" in $$props2)
      slugger = $$props2.slugger;
    if ("combinedRenderers" in $$props2)
      $$invalidate(1, combinedRenderers = $$props2.combinedRenderers);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*source*/
    4) {
      $:
        $$invalidate(8, preprocessed = Array.isArray(source));
    }
    if ($$self.$$.dirty & /*source*/
    4) {
      $:
        slugger = source ? new Slugger() : void 0;
    }
    if ($$self.$$.dirty & /*options*/
    16) {
      $:
        $$invalidate(9, combinedOptions = { ...defaultOptions, ...options });
    }
    if ($$self.$$.dirty & /*preprocessed, source, combinedOptions, isInline, lexer, tokens*/
    869) {
      $:
        if (preprocessed) {
          $$invalidate(0, tokens = source);
        } else {
          $$invalidate(6, lexer = new Lexer(combinedOptions));
          $$invalidate(0, tokens = isInline ? lexer.inlineTokens(source) : lexer.lex(source));
          dispatch("parsed", { tokens });
        }
    }
    if ($$self.$$.dirty & /*renderers*/
    8) {
      $:
        $$invalidate(1, combinedRenderers = { ...defaultRenderers, ...renderers });
    }
    if ($$self.$$.dirty & /*mounted, preprocessed, tokens*/
    385) {
      $:
        mounted && !preprocessed && dispatch("parsed", { tokens });
    }
  };
  return [
    tokens,
    combinedRenderers,
    source,
    renderers,
    options,
    isInline,
    lexer,
    mounted,
    preprocessed,
    combinedOptions
  ];
}
var SvelteMarkdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {
      source: 2,
      renderers: 3,
      options: 4,
      isInline: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteMarkdown",
      options,
      id: create_fragment23.name
    });
  }
  get source() {
    throw new Error("<SvelteMarkdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<SvelteMarkdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderers() {
    throw new Error("<SvelteMarkdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderers(value) {
    throw new Error("<SvelteMarkdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<SvelteMarkdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<SvelteMarkdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isInline() {
    throw new Error("<SvelteMarkdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isInline(value) {
    throw new Error("<SvelteMarkdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteMarkdown_default = SvelteMarkdown;

// node_modules/svelte-markdown/src/index.js
var src_default = SvelteMarkdown_default;
export {
  src_default as default
};
//# sourceMappingURL=svelte-markdown.js.map
